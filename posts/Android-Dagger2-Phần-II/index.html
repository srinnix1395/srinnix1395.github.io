<!DOCTYPE html><html lang="en-US" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="[Android] Dagger 2 - Phần II: Into the Dagger 2" /><meta property="og:locale" content="en_US" /><meta name="description" content="Bài viết là phần thứ II của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc phần trước, bạn có thể ghi danh vào lớp học tại đây" /><meta property="og:description" content="Bài viết là phần thứ II của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc phần trước, bạn có thể ghi danh vào lớp học tại đây" /><link rel="canonical" href="https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-II/" /><meta property="og:url" content="https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-II/" /><meta property="og:site_name" content="srinnix13" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-20T07:42:02+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Android] Dagger 2 - Phần II: Into the Dagger 2" /><meta name="twitter:site" content="@srinnix13" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Bài viết là phần thứ II của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc phần trước, bạn có thể ghi danh vào lớp học tại đây","headline":"[Android] Dagger 2 - Phần II: Into the Dagger 2","dateModified":"2021-04-20T09:17:05+00:00","datePublished":"2021-04-20T07:42:02+00:00","url":"https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-II/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-II/"},"@context":"https://schema.org"}</script><title>[Android] Dagger 2 - Phần II: Into the Dagger 2 | srinnix13</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/resources/github_avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">srinnix13</a></div><div class="site-subtitle font-italic">The man who is looking for an olive branch and a piece of cheese, of course!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/srinnix1395" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/srinnix13" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/srinnix13" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['srinnix13','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[Android] Dagger 2 - Phần II: Into the Dagger 2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Android] Dagger 2 - Phần II: Into the Dagger 2</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> tuha3 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Apr 20, 2021, 7:42 AM +0000" prep="on" > Apr 20 <i class="unloaded">2021-04-20T07:42:02+00:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Apr 20, 2021, 4:17 PM +0700" prefix="Updated " > Apr 20 <i class="unloaded">2021-04-20T09:17:05+00:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3986 words">22 min</span></div></div><div class="post-content"><p>Bài viết là phần thứ II của series bài học vỡ lòng về <em>Dagger 2</em>. Nếu bạn chưa đọc phần trước, bạn có thể ghi danh vào lớp học <a href="https://kipalog.com/posts/Android--Dagger-2---Phan-I--Basic-principles">tại đây</a></p><h1 id="các-bài-học-để-lên-lớp">Các bài học để lên lớp</h1><ol><li><a href="https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-I/">[Android] Dagger 2 - Phần I: Basic principles</a><li>[Android] Dagger 2 - Phần II: Into the Dagger 2<li><a href="https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/">[Android] Dagger 2 - Phần III - 1: The time of our dependencies</a><li><a href="https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-2/">[Android] Dagger 2 - Phần III - 2: The time of our dependencies</a><li><a href="">[Android] Dagger 2 - Phần IV: A new horizon</a></ol><h1 id="trong-bài-học-trước">Trong bài học trước…</h1><p>Chúng ta đã nói một chút về việc khởi tạo và quản lý dependency. Tiếp đó, chúng ta ngờ ngợ ra những vấn đề khi ứng dụng được scale up lên. Cuối cùng, chúng ta được giác ngộ với những design principle và design pattern có thể giải quyết giả thiết của bài toán ban đầu.</p><h1 id="đi-vào-bài-học-hôm-nay">Đi vào bài học hôm nay…</h1><p>Chúng ta sẽ tìm hiểu sâu hơn về <em>Dagger 2</em>: trước là lý thuyết và sau là từng bước implement một chương trình đơn giản.</p><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/y1bh782i5k_fredrik-ohlander-MU2pWu95UqA-unsplash.jpg" /> Photo by <a href="https://unsplash.com/@fredrikohlander?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Fredrik Öhlander</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p><p>Một chút kiến thức lịch sử, <em>Dagger</em> là một library được <em>Square</em> tạo ra để implement <em>dependency injection</em> trong <em>Java</em> (<em>Android</em> là một trường hợp cụ thể hơn). <em>Dagger 1</em> là một <em>dynamic, run-time DI framework</em> và đã deprecated. <em>Dagger 1</em> khởi tạo các dependency “động”, tức là việc tạo ra dependency được thực hiện lúc run-time thông qua java reflection. Bởi vậy, nó có nhược điểm là chậm và có thể có run-time exception xảy ra khi chạy ứng dụng.</p><p><em>Dagger 2</em> được tiếp nối bởi <em>Google</em> và là một <em>fully static, compile-time DI framework</em>. Để khắc phục những nhược điểm của người tiền nhiệm, <em>Dagger 2</em> sử dụng <em>annotation processor</em> (a code generator using annotation) để “viết” code cho chúng ta khi compile. Bởi vậy, nếu có lỗi gì, <em>Dagger</em> sẽ báo cho chúng ta và dừng quá trình build chương trình. Cùng với đó, nguyên tắc để gen ra các đoạn code này là cố gắng bắt chước những đoạn code mà người dùng thực sự sẽ viết. Từ đó, code cũng sẽ đơn giản và khả thi hơn khi trace.</p><p>Để bắt đầu với <em>Dagger 2</em>, chúng ta cần nói qua về một khái niệm quan trọng trong <em>Dagger</em> mà chúng ta hay được nghe tới nhưng lại ít được giải thích tường minh. Đó là <em>dependency graph</em>.</p><h1 id="dependency-graph">Dependency graph</h1><p><em>Dependency graph</em> trong <em>Dagger</em> có thể hiểu là một cái graph biểu diễn những mối quan hệ của các class với những dependency của nó. <em>Dependency graph</em> được biểu diễn bằng một <em>Directed A-cyclic Graph</em> - đồ thị có hướng không tuần hoàn (hay chính là <em>DAG</em> trong <em>Dagger</em>).</p><p>Chúng ta sẽ sửa đổi một chút ví dụ bài trước và tạo ra một <em>dependency graph</em> để hiểu rõ hơn khái niệm này:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>class Student {

    var book: TextBook

    var pen: Pen

    constructor(book: TextBook, pen: Pen) {
       this.book = book
        this.pen = pen
    }

    fun learn() {
        println("Using a ${pen.ink.color} pen  to learning ${book.getSubjectName()}")
    }
}

data class Pen (val ink: Ink)

data class Ink(val color: String = "Black")
</pre></table></code></div></div><p>… và đây là <em>dependency graph</em> tương ứng:</p><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/p2g5hyoqsd_Screenshot%20from%202021-03-25%2017-47-37.png" /></p><p>Ở đây, mỗi mũi tên có hướng trong đồ thị biểu diễn một mối quan hệ phụ thuộc: <code class="language-plaintext highlighter-rouge">Student</code>phụ thuộc vào <code class="language-plaintext highlighter-rouge">TextBook</code> và <code class="language-plaintext highlighter-rouge">Pen</code>, <code class="language-plaintext highlighter-rouge">Pen</code> phụ thuộc vào <code class="language-plaintext highlighter-rouge">Ink</code>. Vì những sự phụ thuộc này, ta cần khởi tạo các module cấp thấp trước rồi mới có thể khởi tạo được các module cấp cao: khởi tạo <code class="language-plaintext highlighter-rouge">Ink</code> trước rồi mới đến <code class="language-plaintext highlighter-rouge">Pen</code>. Và cũng bởi vì cần có thứ tự khởi tạo trước sau như vậy, <em>dependency graph</em> không thể tồn tại những vòng lặp đóng hay <em>a circular dependency</em> vì <em>Dagger</em> sẽ không biết đâu là điểm khởi tạo đầu tiên.</p><p>Khi implement <em>Dagger</em>, mục tiêu của chúng ta là cần fulfill <em>dependency graph</em> trước - cung cấp cho <em>Dagger</em> đầy đủ cách khởi tạo của các phần tử trong <em>dependency grapgh</em> và giao phần việc còn lại cho <em>Dagger</em>. VD: để khởi tạo <code class="language-plaintext highlighter-rouge">Pen</code>, ta cần khởi tạo <code class="language-plaintext highlighter-rouge">Ink</code> trước nên ta cần chỉ cho <em>Dagger</em> biết cách khởi tạo <code class="language-plaintext highlighter-rouge">Ink</code> như thế nào. Nếu ta không thêm <code class="language-plaintext highlighter-rouge">Ink</code> vào <em>dependency graph</em>, <em>Dagger</em> sẽ không biết khởi tạo <code class="language-plaintext highlighter-rouge">Ink</code> như thế nào.</p><p>Vậy, làm thế nào để fulfill <em>dependency graph</em> trong <em>Dagger 2</em>? Câu trả lời là <em>Dagger 2</em> sẽ cung cấp cho chúng ta các annotation để làm việc đó.</p><h1 id="annotation-trong-dagger-2">Annotation trong Dagger 2</h1><p><em>Annotation</em> là một dạng <strong>chú thích</strong> hoặc một dạng <strong>metadata</strong> được dùng để cung cấp thông tin cho mã nguồn <em>Java</em>. <em>Dagger 2</em> sẽ sử dụng các thông tin có được thông qua truy vấn các annotation để gen code khi compile.</p><p>Các annotation cơ bản trong <em>Dagger 2</em> là:</p><ul><li><code class="language-plaintext highlighter-rouge">@Component</code> - đánh dấu một interface/abstract class là <em>injector class</em>, cầu nối giữa cung - <code class="language-plaintext highlighter-rouge">@Module</code> và cầu - <code class="language-plaintext highlighter-rouge">@Inject</code>.<li><code class="language-plaintext highlighter-rouge">@Inject</code> - đánh dấu đâu là constructor để khởi tạo dependency hoặc đâu là nơi cần dependency.<li><code class="language-plaintext highlighter-rouge">@Module</code> - đánh dấu một class/interface, nơi cung cấp các dependency.<li><code class="language-plaintext highlighter-rouge">@Provides</code> - đánh dấu các method nằm bên trong <code class="language-plaintext highlighter-rouge">@Module</code> và thể hiện cách khởi tạo các dependency.<li><code class="language-plaintext highlighter-rouge">@Qualifier</code> - định danh để phân biệt các dependency có cùng kiểu dữ liệu với nhau.<li><code class="language-plaintext highlighter-rouge">@Scope</code> - thể hiện vòng đời (scope) của dependency, từ đó giúp ta tạo ra dependency phù hợp với những trường hợp khác nhau.</ul><p>Nếu đây là lần đầu tiên (có thể là lần thứ n :D) tiếp cận với một loạt các annotation như thế này, hẳn là chúng ta sẽ thấy bị lạc lối, không biết nên bắt đầu thế nào. Tuy nhiên, chúng ta có thể thực hành với một chương trình nhỏ rồi quay lại nghiền ngẫm lý thuyết thì bức tranh sẽ sáng sủa hơn rất nhiều. Lego, chúng ta sẽ implement <em>Dagger 2</em></p><h1 id="the-very-first-basic-program">The very first basic program</h1><p>Chúng ta sẽ có một ứng dụng đơn giản sử dụng mô hình MVP như sau:</p><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/u1dxoya5qb_DaggerMvpBasic.jpg" /></p><p><strong>Note</strong>: Những bạn đã sử dụng mô hình MVP (hoặc đã thấm nhuần tư tưởng của… <em>Dependency inversion</em>) chắc sẽ thắc mắc tại sao việc giao tiếp giữa các layer chẳng có interface gì cả!?! Tuy nhiên, mình xin phép bắt đầu với một ứng dụng “cộc lốc” này trước. Sau đó, chúng ta sẽ dần dần trả món “nợ kỹ thuật” này bằng cách implement đầy đủ các interface nhằm thỏa mãn <em>DIP</em> để ứng dụng sát với thực tế nhất.</p><p>Nhìn vào mối quan hệ giữa các class, ta thấy cần phải build một <em>dependency graph</em> với các mối quan hệ sau:</p><ul><li>Presenter là dependency của Activity<li>Repository là dependency của Presenter<li>ApiHelper, PreferenceHelper và DbHelper là dependency của Repository</ul><p>Và để bắt đầu, chúng ta sẽ đến với annotation cơ bản đầu tiên trong <em>Dagger 2</em>: <code class="language-plaintext highlighter-rouge">@Inject</code></p><h3 id="inject">@Inject</h3><p>Mục đích đầu tiên của <code class="language-plaintext highlighter-rouge">@Inject</code> mà ta sẽ sử dụng tới là để thêm một class vào <em>dependency graph</em>. Để làm điều đó, chúng ta sẽ thêm <code class="language-plaintext highlighter-rouge">@Inject</code> vào constructor của class.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>class MainPresenter @Inject constructor(var repository: MainRepository) { ... }
</pre></table></code></div></div><p>Tuy nhiên, sau khi thử build project phát, chúng ta lại gặp lỗi sau:</p><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/h33194h6xa_Screenshot%20from%202021-04-08%2009-54-39.png" /> Không provide `MainRepository` thì tao khởi tạo `MainPresenter` bằng niềm tin ah~~</p><p>Error này có kiểu là một <code class="language-plaintext highlighter-rouge">[Dagger/MissingBinding]</code> error. Giải thích một cách nôm na là: <em>Dagger</em> không biết cung cấp <code class="language-plaintext highlighter-rouge">MainRepository</code> như thế nào vì không tìm thấy nó trong <em>dependency grapgh</em>. Bởi vậy, ta thêm <code class="language-plaintext highlighter-rouge">@Inject</code> cho constructor của <code class="language-plaintext highlighter-rouge">MainRepository</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>class MainRepository @Inject constructor(var apiHelper: ApiHelper,
                                         var preferenceHelper: PreferenceHelper,
                                         var dbHelper: DbHelper) { ... }
</pre></table></code></div></div><p>Tương tự với các dependency của <code class="language-plaintext highlighter-rouge">MainRepository</code>, chúng ta cũng cần thêm <code class="language-plaintext highlighter-rouge">@Inject</code> vào constructor để <em>dependency graph</em> thêm phần đầy đặn:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>class ApiHelper @Inject constructor() { ... }
class PreferenceHelper @Inject constructor() { ... }
class DbHelper @Inject constructor() { ... }
</pre></table></code></div></div><p><strong>Note</strong>: Nhớ lại một chút phần I về <a href="https://kipalog.com/posts/Android--Dagger-2---Phan-I--Cac-khai-niem-co-ban#toc-c-c-ki-u-inject">Các kiểu inject</a>, chúng ta nhận ra rằng chúng ta đang sử dụng <em>constructor injection</em>.</p><p>Vậy là chúng ta đã hoàn thành việc khai báo những phần tử có mặt trong <em>dependency graph</em>. Dây chính là các <em>service class</em> đã nói trong phần I. Tiếp theo, chúng ta cần khai báo <em>injector class</em>, đó là một class trung gian và có nhiệm vụ kết nối <em>service class</em> - nơi cung cấp dependency và <em>client class</em> - nơi cần dependency. Để tạo ra một <em>injector class</em> trong <em>Dagger 2</em>, chúng ta sử dụng annotation <code class="language-plaintext highlighter-rouge">@Component</code></p><h3 id="component">@Component</h3><p>Component trong <em>Dagger 2</em> là một interface được annotate với <code class="language-plaintext highlighter-rouge">@Component</code>. <em>Dagger</em> sẽ sử dụng component và các thông tin chúng ta khai báo thông qua <code class="language-plaintext highlighter-rouge">@Inject</code> và build lên <em>dependency graph</em> thỏa mãn các mối quan hệ mà chúng ta đã khai báo. Bên trong component này, chúng ta có thể khai báo các function trả về các dependency mà chúng ta cần(<code class="language-plaintext highlighter-rouge">MainPresenter</code>).</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>@Component
interface MainComponent {
    fun mainPresenter(): MainPresenter
}
</pre></table></code></div></div><p><strong>Note</strong>: <em>Dagger</em> không quan tâm tên của function này là gì, nó chỉ cần kiểu mà function này trả về để expose ra đúng function mà nó gen ra.</p><p>Tiếp đó, chúng ta cần phải build project để <em>Dagger</em> gen code cho chúng ta. Sau khi build xong, ta sẽ thấy code được <em>Dagger</em> gen ra trong thư mục <code class="language-plaintext highlighter-rouge">app/build/generated/source</code>, các bạn có thể đọc để thấy code cũng tương đối dễ hiểu ;). Và class mà chúng ta cần quan tâm là <code class="language-plaintext highlighter-rouge">DaggerMainComponent</code>. Class này được gen ra từ interface component ở trên với format tên là <em>Dagger</em> + <em>Component name</em> . Class này sẽ implement interface component và override lại các function mà chúng ta khai báo bên trong interface. Thông qua những function này, chúng ta có thể lấy ra dependency cần thiết mà không cần quan tâm các dependency này được khởi tạo ở đâu và quản lý như thế nào.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>class MainActivity : FragmentActivity() {

    private lateinit var mainPresenter: MainPresenter

    override fun onCreate(savedInstanceState: Bundle?) {
        ...

        // initialize the component
        val mainComponent = DaggerMainComponent.create()

        // ... and get the dependency
        mainPresenter = mainComponent.mainPresenter()
    }
}
</pre></table></code></div></div><p>Tuy nhiên, dependency cũng có dependency this, dependency that, không phải class nào cũng do chúng ta tạo ra hay có kiểu là một class có thể khởi tạo được(interface/abstract class). Bởi vậy, chúng ta cần thêm một “cái kho”, nơi chúng ta chỉ cho <em>Dagger</em> biết cách khởi tạo các dependency that này. Cái kho đó trong <em>Dagger 2</em> gọi là các module.</p><h3 id="module">@Module</h3><p>Module trong <em>Dagger 2</em> có thể là một class hoặc một abstract class được annotate với <code class="language-plaintext highlighter-rouge">@Module</code>, nơi chúng ta cung cấp những dependency muốn thêm vào <em>dependency graph</em>. Khi build <em>dependency graph</em>, Dagger component ngoài tìm kiếm ở những constructor có annotation <code class="language-plaintext highlighter-rouge">@Inject</code> như chúng ta đã làm ở trên, nó sẽ tìm thêm trong các module được gắn với nó.</p><div class="table-wrapper"><table><tbody><tr><td><strong>Note</strong>: Có một misconception rằng không có module thì <em>Dagger 2</em> không gáy được :<td>. Tuy nhiên, chương trình đang xét cho ta thấy rằng không nhất thiết cần có các module trong trường hợp dependency đều là những class có thể khởi tạo được thông qua constructor. Chỉ cho <em>Dagger</em> biết cách khởi tạo một dependency thông qua module là 1 cách nhưng không phải là duy nhất.</table></div><p>Tiếp tục ví dụ ở trển với một requirement mới, chúng ta cần thêm library <em>Retrofit</em> để call API và sử dụng <em>Gson</em> để parse object. Bởi vậy, chúng ta sẽ tạo một API service là <code class="language-plaintext highlighter-rouge">MainService</code> chứa các API của màn hình <code class="language-plaintext highlighter-rouge">MainActivity</code>. Các bước để config <em>Retrofit</em> và tạo <code class="language-plaintext highlighter-rouge">MainService</code> là:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>val baseUrl = "..."
val gson = GsonBuilder().setDateFormat("ddMMyyyy").create()
val retrofit = Retrofit.Builder()
            .addConverterFactory(GsonConverterFactory.create(gson))
            .baseUrl(baseUrl)
            .build()

val mainService: MainService = retrofit.create(MainService::class.java)
</pre></table></code></div></div><p>Ta thấy <code class="language-plaintext highlighter-rouge">Retrofit</code>, <code class="language-plaintext highlighter-rouge">Gson</code> và <code class="language-plaintext highlighter-rouge">MainService</code> đều là những “dependency that” đã được nói tới. Vậy thì tạo ra một module ngay thôi chứ còn chờ đợi chi? Để một class được coi là một module, ta chỉ cần thêm annotation <code class="language-plaintext highlighter-rouge">@Module</code> vào trước phần khai báo class đó.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>@Module
class ApiModule { ... }
</pre></table></code></div></div><h5 id="provides">@Provides</h5><p>Bên trong module, chúng ta cần chỉ cho <em>Dagger</em> biết cách khởi tạo dependency bằng cách khai báo các function được annotate với <code class="language-plaintext highlighter-rouge">@Provides</code> và trả về kiểu của dependency mà chúng ta cần. Với đoạn code config <em>Retrofit</em> và khởi tạo <code class="language-plaintext highlighter-rouge">MainService</code> ở trên, chúng ta có thể tách ra thành 4 function riêng rẽ trả về 4 dependency chúng ta mong muốn:<code class="language-plaintext highlighter-rouge">baseUrl</code>, <code class="language-plaintext highlighter-rouge">gson</code>, <code class="language-plaintext highlighter-rouge">retrofit</code> và <code class="language-plaintext highlighter-rouge">mainService</code> để sau này nếu có chỗ khác cần, code sẽ không bị lặp.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>@Provides
fun provideRetrofit(baseUrl: String, gson: Gson): Retrofit {
    return Retrofit.Builder()
        .addConverterFactory(GsonConverterFactory.create(gson))
        .baseUrl(baseUrl)
        .build()
}

@Provides
fun provideBaseUrl(): String {
    return "..."
}

@Provides
fun provideGson(): Gson {
    return GsonBuilder().setDateFormat("ddMMyyyy").create()
}

@Provides
fun provideMainService(retrofit: Retrofit): MainService {
    return retrofit.create(MainService::class.java)
}
</pre></table></code></div></div><p><strong>Note</strong>: Tên của các provide function và thứ tự của các function đó trong module không quan trọng mà quan trọng là kiểu trả về của các function đó, <em>Dagger</em> sẽ dựa vào đó mà thêm các class vào <em>dependency graph</em>. Trong trường hợp trên: để provide <code class="language-plaintext highlighter-rouge">MainService</code>, chúng ta cần một object <code class="language-plaintext highlighter-rouge">Retrofit</code>. Bởi vậy, chúng ta sẽ provide thêm <code class="language-plaintext highlighter-rouge">Retrofit</code>. Để khởi tạo <code class="language-plaintext highlighter-rouge">Retrofit</code>, chúng ta lại cần có một <code class="language-plaintext highlighter-rouge">String</code> và một object <code class="language-plaintext highlighter-rouge">Gson</code>. Vì thế, chúng ta tiếp tục provide thêm <code class="language-plaintext highlighter-rouge">Gson</code> và <code class="language-plaintext highlighter-rouge">String</code>. Vậy là đã thỏa mãn được tất cả các dependency để có thể khởi tạo <code class="language-plaintext highlighter-rouge">MainService</code>.</p><p>Ngoài ra, <em>Dagger</em> cho phép chúng ta gắn nhiều module vào một component giúp cho các module đó được thông với nhau nên dependency cung cấp ở module này có thể provide cho dependency ở module kia. Bởi vậy, các bạn nên nhóm các dependency liên quan vào một module để code không bị lặp. VD: <code class="language-plaintext highlighter-rouge">UtilsModule</code></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>@Module
class UtilsModule {

    private var mContext: Context

    constructor(context: Context) {
        this.mContext = context
    }

    @Provides
    fun provideContext(): Context {
        return mContext
    }
}
</pre></table></code></div></div><p>Khác với <code class="language-plaintext highlighter-rouge">ApiModule</code> không có một dependency nào, <code class="language-plaintext highlighter-rouge">UtilsModule</code> cần một dependency có kiểu <code class="language-plaintext highlighter-rouge">Context</code>. Tuy nhiên, <code class="language-plaintext highlighter-rouge">Context</code> lại được tạo ra bởi Android system và do đó object <code class="language-plaintext highlighter-rouge">Context</code> nên được truyền vào khi khởi tạo module khi nó available.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>val mainComponent = DaggerMainComponent.builder()
            .utilsModule(UtilsModule(this))
            .build()
mainPresenter = mainComponent.mainPresenter()
</pre></table></code></div></div><p><strong>Note</strong>: Trong trường hợp module không cần một dependency nào từ bên ngoài:</p><ul><li>Chúng ta không nhất thiết phải tự khởi tạo và truyền vào cho component bởi component sẽ tự khởi tạo ở bên dưới.<li>Chúng ta có thể khai báo nó là môt <code class="language-plaintext highlighter-rouge">object</code> class để module chỉ cần khởi tạo một lần duy nhất.<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>@Module
object ApiModule { ... }
</pre></table></code></div></div></ul><h5 id="bind">@Bind</h5><p>Quay lại với quả <a href="https://buihuycuong.medium.com/technical-debt-n%E1%BB%A3-k%E1%BB%B9-thu%E1%BA%ADt-6a312eb5eb42">bát họ kỹ thuật</a> đã bốc từ đầu bài viết khi chúng ta chỉ sử dụng concrete type và từ chối abstract type nhằm giảm độ phức tạp của chương trình. Và vui mừng là chúng ta đã có đủ kiến thức để giải quyết vấn đề rồi. It’s payback time!</p><p>Chúng ta sẽ tạo thêm các interface và sử dụng các interface đấy thay vì các concrete class:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>interface MainPresenter { ... }
class MainPresenterImpl @Inject constructor(var repository: MainRepository) : MainPresenter { ... }

interface MainRepository { ... }
class MainRepositoryImpl @Inject constructor(var apiHelper: ApiHelper,
                                             var preferenceHelper: PreferenceHelper,
                                             var dbHelper: DbHelper) : MainRepository { ... }
</pre></table></code></div></div><p>Vậy là giờ đây, các dependency là các interface thay vì các class có thể khởi tạo được nên bắt buộc chúng ta phải provide chúng thông qua các module:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>@Module
object PresenterModule {

    @Provides
    @JvmStatic
    fun provideMainPresenter(mainPresenterImpl: MainPresenterImpl): MainPresenter {
        return mainPresenterImpl
    }
}

@Module
object RepositoryModule {

    @Provides
    @JvmStatic
    fun provideMainRepository(mainRepositoryImpl: MainRepositoryImpl): MainRepository {
        return mainRepositoryImpl
    }
}
</pre></table></code></div></div><p><strong>Note</strong>: Các dependency còn lại như <code class="language-plaintext highlighter-rouge">ApiHelper</code>, <code class="language-plaintext highlighter-rouge">PreferenceHelper</code> và <code class="language-plaintext highlighter-rouge">DbHelper</code> thì các bạn làm tương tự nhé: <code class="language-plaintext highlighter-rouge">ctrl-c</code>, <code class="language-plaintext highlighter-rouge">ctrl-vvvvvvvv</code> :D</p><p>Các bạn có thể thấy cách khai báo các dependency này là hoàn toàn giống nhau về format khi chúng ta provide một interface nhưng lại trả về implementation của interface đó. Trong thực tế, cách provide này là cực kỳ phổ biến khi hầu như bất kỳ ứng dụng nào sử dụng <em>Dagger 2</em> đều sẽ có những provide function như thế. Bởi vậy, <em>Dagger</em> cung cấp cho chúng ta một annotation để giảm những đoạn boilerplate code này đi: <code class="language-plaintext highlighter-rouge">@Binds</code></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>@Module
abstract class PresenterModule {

    @Binds
    abstract fun provideMainPresenter(mainPresenterImpl: MainPresenterImpl): MainPresenter
}

@Module
abstract class RepositoryModule {

    @Binds
    abstract fun provideMainRepository(mainRepositoryImpl: MainRepositoryImpl): MainRepository
}
</pre></table></code></div></div><p><strong>Note</strong>: Các binding function cần phải nằm trong một abstract class module và module này không được chứa lẫn lộn cả binding function và provides function. Đó là vì cách <em>Dagger</em> sử dụng thông tin có được từ 2 annotation này để khởi tạo dependency là khác nhau:</p><ul><li>Với <code class="language-plaintext highlighter-rouge">@Provides</code>, <em>Dagger</em> sẽ sử dụng chính function chúng ta khai báo để khởi tạo dependency. Màu vàng ở tên function thể hiện <em>Dagger</em> đang sử dụng function:</ul><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wu9kw7664c_module_provide_function.png" /></p><ul><li>Với <code class="language-plaintext highlighter-rouge">@Binds</code>, <em>Dagger</em> chỉ lấy thông tin của function: kiểu trả về và kiểu của tham số truyền vào thay vì dùng luôn function. Màu ghi ở tên function thể hiện function đang không được sử dụng ở đâu:</ul><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/n8qu24f7d0_module_bind_function.png" /></p><p>Để hiểu kỹ hơn, các bạn có thể tham khảo <a href="https://dagger.dev/dev-guide/faq.html#why-is-binds-different-from-provides">ở đây</a>.</p><h3 id="qualifier">@Qualifier</h3><p>Khi provide các dependency cho <em>Dagger</em>, chúng ta có thể gặp phải tình huống 2 dependency khác nhau nhưng có cùng kiểu dữ liệu. Để giải quyết vấn đề này, <em>Dagger</em> cung cấp cho chúng ta annotaion <code class="language-plaintext highlighter-rouge">@Qualifier</code> nhằm phân biệt các dependency với nhau.</p><p>Có 2 cách để sử dụng annotaion này:</p><ul><li>Sử dụng một qualifier annotation có sẵn của <em>Dagger</em>: <code class="language-plaintext highlighter-rouge">@Named</code><li>Tự tạo ra một annotation và annotate nó với <code class="language-plaintext highlighter-rouge">@Qualifier</code></ul><h5 id="named">@Named</h5><p>Trong ví dụ ở trên, giả sử chúng ta cần 2 object <code class="language-plaintext highlighter-rouge">Retrofit</code> với 2 config khác nhau: <code class="language-plaintext highlighter-rouge">Authentication</code> và <code class="language-plaintext highlighter-rouge">No-Authentication</code>. Chúng ta có thể tạo thêm một provide function nữa và thêm <code class="language-plaintext highlighter-rouge">@Named</code> để phân biệt 2 dependency đó:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>@Provides
@Named("No-Authentication")
fun provideRetrofitNoAuthentication(baseUrl: String, gson: Gson): Retrofit {
    return Retrofit.Builder()
        .baseUrl(baseUrl)
        .addConverterFactory(GsonConverterFactory.create(gson))
        .build()
}

@Provides
@Named("Authentication")
fun provideRetrofitAuthentication(baseUrl: String, okHttpClient: OkHttpClient, gson: Gson): Retrofit {
    return Retrofit.Builder()
        .baseUrl(baseUrl)
        .addConverterFactory(GsonConverterFactory.create(gson))
        .client(okHttpClient)
        .build()
}

@Provides
fun provideOkHttp(): OkHttpClient { ... }
</pre></table></code></div></div><p>Cùng với đó, ở tất cả những chỗ sử dụng <code class="language-plaintext highlighter-rouge">Retrofit</code> cũng cần sử dụng <code class="language-plaintext highlighter-rouge">@Named</code> để chỉ rõ dependency cần dùng là loại nào</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>@Provides
fun provideMainService(@Named("No-Authentication") retrofit: Retrofit): MainService {
    return retrofit.create(MainService::class.java)
}
</pre></table></code></div></div><h5 id="tạo-ra-một-qualifier-annotation-mới">Tạo ra một qualifier annotation mới</h5><p>Để tạo ra một qualifier annotation, chúng ta chỉ cần tạo ra một annotation và annotate nó với <code class="language-plaintext highlighter-rouge">@Qualifier</code></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>@Qualifier
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class AuthenticationRetrofit()

@Qualifier
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class NoAuthenticationRetrofit()
</pre></table></code></div></div><p>Cách sử dụng annotation mới này chỉ đơn giản là chúng ta thay thế <code class="language-plaintext highlighter-rouge">@Named</code> bằng annotation mới:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>@Provides
@AuthenticationRetrofit
fun provideRetrofitNoAuthentication(baseUrl: String, gson: Gson): Retrofit { ... }

@Provides
@NoAuthenticationRetrofit
fun provideRetrofitAuthentication(baseUrl: String, okHttpClient: OkHttpClient, gson: Gson): Retrofit { ... }

@Provides
fun provideMainService(@NoAuthenticationRetrofit retrofit: Retrofit): MainService { ... }
</pre></table></code></div></div><h3 id="property-injection">Property injection</h3><p>Trong phần I của series, chúng ta biết có <a href="https://kipalog.com/posts/Android--Dagger-2---Phan-I--Basic-principles#toc-c-c-ki-u-inject">3 cách để inject</a> một dependency. Tuy nhiên từ đầu bài viết, chúng ta mới chỉ sử dụng 1 cách inject duy nhất. Đó là <em>constructor injection</em>. Cách inject này thì đơn giản và được khuyên dùng, nhưng chúng ta lại không thể sử dụng nó đối với những class mà việc khởi tạo không phải do chúng ta đảm nhiệm: <code class="language-plaintext highlighter-rouge">Activity</code>, <code class="language-plaintext highlighter-rouge">Fragment</code>, <code class="language-plaintext highlighter-rouge">Service</code>, etc. Ngoài ra, cách lấy dependency từ <em>Dagger component</em> ra còn một vấn đề là khi số lượng dependency tăng lên, chúng ta cũng phải nhớ mà lấy ra đầy đủ trước khi sử dụng để tránh làm chương trình crash. Để giải quyết điều này, chúng ta sẽ sử dụng đến một cách inject khác: <em>property injection</em>.</p><p>Đầu tiên, chúng ta cần annotate dependency bằng <code class="language-plaintext highlighter-rouge">@Inject</code> và để access modifier của dependency là package-private trở lên - <code class="language-plaintext highlighter-rouge">internal</code> hoặc <code class="language-plaintext highlighter-rouge">public</code> trong <em>Kotlin</em> (vì cơ chế của cách inject này thực chất là component gán giá trị trực tiếp cho dependency):</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>@Inject
lateinit var mainPresenter: MainPresenter
</pre></table></code></div></div><p>Tiếp đó, chúng ta cần khai báo thêm một function vào component để <em>Dagger</em> biết chúng ta muốn inject dependency vào class nào. Kiểu của tham số truyền vào function sẽ là class muốn được inject. Nếu có thêm class muốn được inject, chúng ta cần khai báo thêm các function tương tự với kiểu của tham số tương ứng.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>@Component(modules = [UtilsModule::class, PresenterModule::class, RepositoryModule::class,  ApiModule::class])
interface MainComponent {
    fun inject(mainActivity: MainActivity)
}
</pre></table></code></div></div><p><strong>Note</strong>: Đến đây, chúng ta thấy sẽ có 2 cách để giao tiếp với <em>dependency graph</em>:</p><ul><li>Khai báo một function không có tham số và trả về một class mà bạn muốn trực tiếp lấy ra.<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>fun mainPresenter(): MainPresenter
</pre></table></code></div></div><li>Khai báo một function không trả về giá trị nào và có một tham số là class mà bạn muốn inject các dependecy bằng <em>property injection</em><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>fun inject(mainActivity: MainActivity)
</pre></table></code></div></div></ul><p>Cuối cùng, thay vì lấy dependency ra từ component, chúng ta gọi function vừa được khai báo trong component kia để <em>Dagger</em> inject tất cả các dependency mà đã được annotate với <code class="language-plaintext highlighter-rouge">@Inject</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>// initialize the component
val mainComponent = DaggerMainComponent.create()

// inject dependencies to this class
mainComponent.inject(this)
</pre></table></code></div></div><p><strong>Note</strong>: Khi sử dụng <em>property inject</em> với Activity, việc khởi tạo vào inject nên được thực hiện trước <code class="language-plaintext highlighter-rouge">super.onCreate()</code> để tránh gặp phải issue restore của Fragment vì khi <code class="language-plaintext highlighter-rouge">super.onCreate()</code> được thực hiện, Activity có thể attach Fragment và các Fragment thì lại muốn truy cập đến các member của Activity. Bởi vậy, chúng ta nên follow best practice sau:</p><ul><li>Với Activity, inject Dagger bên trong method <code class="language-plaintext highlighter-rouge">onCreate()</code> nhưng trước khi gọi <code class="language-plaintext highlighter-rouge">super.onCreate()</code>.<li>Với Fragment, inject Dagger bên trong method <code class="language-plaintext highlighter-rouge">onAttach()</code> nhưng sau khi gọi <code class="language-plaintext highlighter-rouge">super.onAttach()</code>.</ul><h1 id="cùng-nhìn-lại">Cùng nhìn lại</h1><p>Cuối cùng, sau khi đã hoàn thành việc khai báo các dependency không mấy khó khăn, phần việc nhàm chán còn lại là khởi tạo và quản lý các dependency, <em>Dagger</em> sẽ lo hết cho chúng ta. Diagram dưới đây sẽ thể hiển mối quan hệ giữa các thành phần trong <em>Dagger</em>:</p><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/n2ii3pdtil_Dagger2_component.jpg" /></p><p>Gòi xong, chúng ta đã đi qua hầu hết các kiến thức cơ bản của <em>Dagger 2</em>, hy vọng với những kiến thức nhiêu đây, bạn đã có thể bắt đầu sử dụng <em>Dagger 2</em> mà không cảm thấy lạc lối nữa. Tuy chương trình trên đây chỉ là một chương trình nhỏ, chúng ta có thể sẽ chưa thấy hết được sức mạnh của <em>Dagger 2</em> khi các dependency là chưa nhiều. Tuy nhiên, với một ứng dụng phức tạp hơn với nhiều màn hình hơn, mỗi màn hình sẽ sử dụng một loạt các dependency kèm theo thì việc khởi tạo và quản lý sẽ rất mất thời gian khi phải viết rất nhiều những đoạn boilerplate code và còn dễ gây ra lỗi nữa. <em>Dagger 2</em> chính là “the right tool” giúp chúng ta loại bỏ mốí quan tâm đấy và tập trung vào các phần quan trọng hơn của chương trình.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >android</a> <a href="/tags/dependency-injection/" class="post-tag no-text-decoration" >dependency injection</a> <a href="/tags/dagger/" class="post-tag no-text-decoration" >dagger</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Android] Dagger 2 - Phần II: Into the Dagger 2 - srinnix13&url=https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-II/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Android] Dagger 2 - Phần II: Into the Dagger 2 - srinnix13&u=https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-II/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Android] Dagger 2 - Phần II: Into the Dagger 2 - srinnix13&url=https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-II/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-II/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-IV/">[Android] Dagger 2 - Phần IV: A new horizon</a><li><a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-I/">[Android] Dagger 2 - Phần I: Basic principles</a><li><a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-II/">[Android] Dagger 2 - Phần II: Into the Dagger 2</a><li><a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/">[Android] Dagger 2 - Phần III - 1: The time of our dependencies</a><li><a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-2/">[Android] Dagger 2 - Phần III - 2: The time of our dependencies</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/dagger/">dagger</a> <a class="post-tag" href="/tags/dependency-injection/">dependency injection</a> <a class="post-tag" href="/tags/bitmap/">bitmap</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/image/">image</a> <a class="post-tag" href="/tags/layout/">layout</a> <a class="post-tag" href="/tags/recyclerview/">recyclerview</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-I/"><div class="card-body"> <span class="timeago small" > Apr 20 <i class="unloaded">2021-04-20T07:42:01+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] Dagger 2 - Phần I: Basic principles</h3><div class="text-muted small"><p> Mình biết đến Dagger (chính xác là Dagger 2) khi còn đi thực tập ở một công ty. Vì chỉ là một android intern làm việc 4 tiếng một ngày nên công việc chính của mình chỉ là fix một vài cái issue bé b...</p></div></div></a></div><div class="card"> <a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/"><div class="card-body"> <span class="timeago small" > Apr 20 <i class="unloaded">2021-04-20T07:42:03+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] Dagger 2 - Phần III - 1: The time of our dependencies</h3><div class="text-muted small"><p> Bài viết là phần thứ III của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc các phần trước, bạn có thể ghi danh vào lớp học tại đây Các bài học để lên lớp [Android] Dagger 2 - Phần I: Ba...</p></div></div></a></div><div class="card"> <a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-2/"><div class="card-body"> <span class="timeago small" > Apr 20 <i class="unloaded">2021-04-20T07:42:04+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] Dagger 2 - Phần III - 2: The time of our dependencies</h3><div class="text-muted small"><p> Bài viết là phần thứ III của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc các phần trước, bạn có thể ghi danh vào lớp học tại đây Các bài học để lên lớp [Android] Dagger 2 - Phần I: Ba...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-I/" class="btn btn-outline-primary" prompt="Older"><p>[Android] Dagger 2 - Phần I: Basic principles</p></a> <a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/" class="btn btn-outline-primary" prompt="Newer"><p>[Android] Dagger 2 - Phần III - 1: The time of our dependencies</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/srinnix13">tuha3</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/dagger/">dagger</a> <a class="post-tag" href="/tags/dependency-injection/">dependency injection</a> <a class="post-tag" href="/tags/bitmap/">bitmap</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/image/">image</a> <a class="post-tag" href="/tags/layout/">layout</a> <a class="post-tag" href="/tags/recyclerview/">recyclerview</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://srinnix1395.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
