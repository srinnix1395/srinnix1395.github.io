<!DOCTYPE html><html lang="en-US" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="[Android] Dagger 2 - Phần III - 1: The time of our dependencies" /><meta property="og:locale" content="en_US" /><meta name="description" content="Bài viết là phần thứ III của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc các phần trước, bạn có thể ghi danh vào lớp học tại đây" /><meta property="og:description" content="Bài viết là phần thứ III của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc các phần trước, bạn có thể ghi danh vào lớp học tại đây" /><link rel="canonical" href="https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/" /><meta property="og:url" content="https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/" /><meta property="og:site_name" content="srinnix13" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-20T07:42:03+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Android] Dagger 2 - Phần III - 1: The time of our dependencies" /><meta name="twitter:site" content="@srinnix13" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Bài viết là phần thứ III của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc các phần trước, bạn có thể ghi danh vào lớp học tại đây","headline":"[Android] Dagger 2 - Phần III - 1: The time of our dependencies","dateModified":"2021-04-20T09:17:05+00:00","datePublished":"2021-04-20T07:42:03+00:00","url":"https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/"},"@context":"https://schema.org"}</script><title>[Android] Dagger 2 - Phần III - 1: The time of our dependencies | srinnix13</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/resources/github_avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">srinnix13</a></div><div class="site-subtitle font-italic">The man who is looking for an olive branch and a piece of cheese, of course!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/srinnix1395" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/srinnix13" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/srinnix13" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['srinnix13','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[Android] Dagger 2 - Phần III - 1: The time of our dependencies</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Android] Dagger 2 - Phần III - 1: The time of our dependencies</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> tuha3 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Apr 20, 2021, 7:42 AM +0000" prep="on" > Apr 20 <i class="unloaded">2021-04-20T07:42:03+00:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Apr 20, 2021, 4:17 PM +0700" prefix="Updated " > Apr 20 <i class="unloaded">2021-04-20T09:17:05+00:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2915 words">16 min</span></div></div><div class="post-content"><p>Bài viết là phần thứ III của series bài học vỡ lòng về <em>Dagger 2</em>. Nếu bạn chưa đọc các phần trước, bạn có thể ghi danh vào lớp học <a href="https://kipalog.com/posts/Android--Dagger-2---Phan-I--Basic-principles">tại đây</a></p><h1 id="các-bài-học-để-lên-lớp">Các bài học để lên lớp</h1><ol><li><a href="https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-I/">[Android] Dagger 2 - Phần I: Basic principles</a><li><a href="https://srinnix1395.github.io/posts/Android-Dagger2-Ph%E1%BA%A7n-II/">[Android] Dagger 2 - Phần II: Into the Dagger 2</a><li>[Android] Dagger 2 - Phần III - 1: The time of our dependencies<li><a href="https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-2/">[Android] Dagger 2 - Phần III - 2: The time of our dependencies</a><li><a href="">[Android] Dagger 2 - Phần IV: A new horizon</a></ol><h1 id="trong-bài-học-trước">Trong bài học trước…</h1><p>Chúng ta đã tìm hiểu cách “mô hình hóa” các mối quan hệ giữa class và các dependency thông qua <em>dependency graph</em>. Tiếp đó, chúng ta xây dựng một ứng dụng đơn giản và từng bước áp dụng những annotation cơ bản trong <em>Dagger 2</em> để khởi tạo các dependency.</p><h1 id="đi-vào-bài-học-hôm-nay">Đi vào bài học hôm nay…</h1><p>Chương trình ở phần III này sẽ tiếp tục scale up lên với thêm nhiều màn hình và chức năng. Khi đó, chúng ta sẽ phải đối mặt với những vấn đề mới trong việc quản lý vòng đời của các dependency.</p><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lb2kry1ck4_john-towner-3Kv48NS4WUU-unsplash.jpg" /> Photo by <a href="https://unsplash.com/@heytowner?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">JOHN TOWNER</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p><p>Chúng ta sẽ xây dựng thêm một màn hình để xác thực thông tin user (<code class="language-plaintext highlighter-rouge">LoginActivity</code>) trước khi đến với màn hình chính bên trong <code class="language-plaintext highlighter-rouge">MainActivity</code>. Tương tự như <code class="language-plaintext highlighter-rouge">MainActivity</code>, chúng ta cũng sẽ có các class ăn theo: <code class="language-plaintext highlighter-rouge">LoginPresenter</code>, <code class="language-plaintext highlighter-rouge">LoginRepository</code> và cả các implementation class của chúng.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>class LoginActivity : FragmentActivity() {

    @Inject
    lateinit var mLoginPresenter: LoginPresenter

    override fun onCreate(savedInstanceState: Bundle?) {
        ...

        val userComponent = DaggerUserComponent.builder()
            .utilsModule(UtilsModule(this))
            .build()
        userComponent.inject(this)
    }
}

class LoginPresenterImpl @Inject constructor(var repository: LoginRepository) : LoginPresenter { ... }
class LoginRepositoryImpl @Inject constructor(var apiHelper: ApiHelper,
                                              var preferenceHelper: PreferenceHelper,
                                              var dbHelper: DbHelper) : LoginRepository { ... }
</pre></table></code></div></div><p>Các class này cũng sẽ được inject thông qua <em>Dagger</em> nên ta cũng phải thêm inject function vào component, thêm provide function vào <code class="language-plaintext highlighter-rouge">PresenterModule</code> và <code class="language-plaintext highlighter-rouge">RepositoryModule</code></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>@Component(modules = [UtilsModule::class, PresenterModule::class, RepositoryModule::class,  ApiModule::class])
interface UserComponent {
    ...

    fun inject(loginActivity: LoginActivity)
}

@Module
abstract class PresenterModule {
    ...

    @Binds
    abstract fun provideLoginPresenter(loginPresenterImpl: LoginPresenterImpl): LoginPresenter
}

@Module
abstract class RepositoryModule {
    ...

    @Binds
    abstract fun provideLoginRepository(loginRepositoryImpl: LoginRepositoryImpl): LoginRepository
}
</pre></table></code></div></div><p>Chúng ta thấy rằng <code class="language-plaintext highlighter-rouge">ApiHelper</code>, <code class="language-plaintext highlighter-rouge">PreferenceHelper</code> và <code class="language-plaintext highlighter-rouge">DbHelper</code> đang được sử dụng ở <code class="language-plaintext highlighter-rouge">MainRepositoryImpl</code>, <code class="language-plaintext highlighter-rouge">LoginRepositoryImpl</code> và có thể là ở những repository khác trong tương lai nữa. Bởi vậy, chúng ta muốn chỉ có một instance duy nhất của các class đó được tạo ra thay vì thêm repository thì thêm 3 instance được khởi tạo. Mở rộng ra trong thực tế, sẽ có những trường hợp chúng ta muốn chỉ một và duy nhất một instance được tạo ra vì:</p><ol><li>Chi phí khởi tạo class có thể là không nhỏ và còn tốn nhiều thời gian nữa. VD: Memory cache<li>Một class là dependency của nhiều class khác nhưng cần là duy nhất để đảm bảo tính nhất quán dữ liệu. VD: <code class="language-plaintext highlighter-rouge">UserData</code> sau khi login có thể được sử dụng bởi nhiều <code class="language-plaintext highlighter-rouge">Presenter</code></ol><p>Trong trường hợp implement <em>DI</em> thủ công, chúng ta có thể thỏa mãn yêu cầu trên bằng cách truyền cùng một instance cho nhiều class khác nhau. Nhưng với <em>Dagger</em>, vì không thể can thiệp vào quá trình khởi tạo này nên chúng ta cần báo cho <em>Dagger</em> biết bằng cách sử dụng các <em>scope annotation</em>.</p><h3 id="scope">Scope</h3><p>Giải thích một cách đơn giản, scope trong <em>Dagger</em> cho phép chúng ta quản lý vòng đời của dependency bằng cách gắn vòng đời của dependency vào vòng đời của component, tức là khi component còn “sống” thì dependency vẫn sẽ tồn tại còn khi component “chết” thì dependency cũng được tiễn đi Tây Trúc thỉnh kinh theo. Cơ chế này giúp ta giải quyết vấn đề ở trên khi chỉ một instance duy nhất được provide dù nó được request nhiều lần tại nhiều class khác nhau. Tóm lại là một component thì sẽ chỉ một instance được provide - là <em>singleton</em> đối với component đó.</p><p>Trước khi sử dụng <em>scope annotation</em>, chúng ta sẽ thử request 2 dependency xem có bao nhiêu instance được tạo ra:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>class MainRepositoryImpl @Inject constructor(var apiHelper: ApiHelper,
                                             var preferenceHelper: PreferenceHelper,
                                             var dbHelper: DbHelper,
                                             var dbHelper1: DbHelper
) : MainRepository{
    init {
        println(dbHelper.toString())
        println(dbHelper1.toString())
    }
}
</pre></table></code></div></div><p>Khi run project, chúng ta nhận được 2 instance khác nhau như sau:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>2021-04-09 00:01:26.738 2478-2478/io.srinnix.playground I/System.out: io.srinnix.playground.dagger2.automatic.data.DbHelper@4e7f50e
2021-04-09 00:01:26.739 2478-2478/io.srinnix.playground I/System.out: io.srinnix.playground.dagger2.automatic.data.DbHelper@a41cb2f
</pre></table></code></div></div><p>Ngoài ra, khi nhìn vào code mà <em>Dagger</em> gen ra, chúng ta cũng có thể hiểu tại sao lại có 2 instance được tạo ra:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>public final class DaggerMainComponent implements MainComponent {
    private DaggerMainComponent() { }

    private DbHelper dbHelper() {
        return new DbHelper();
    }
}
</pre></table></code></div></div><p>Với đoạn code phía trên, mỗi lần dependency được request, một instance mới tương ứng sẽ được tạo ra. Lý do cho việc liên tục khởi tạo những instance mới là bởi chúng ta chưa gán cho các dependency một scope nào, hay trạng thái hiện tại của các dependency đang là <em>unscoped</em>. Khi đó, có thể nói dependency đó chưa thuộc về một component duy nhất nào cả nên có thể được truy cập trong toàn bộ chương trình miễn là bạn đã thêm dependency đó vào <em>dependency graph</em>. Để giải quyết vấn đề luôn luôn khởi tạo mới instance này và tái sử dụng lại những dependency đã từng được khởi tạo rồi, chúng ta cần sử dụng <em>scope annotation</em> để “gắn” vòng đời của dependency vào một component cụ thể nào đó. Khi đó, dependency sẽ được khởi tạo một lần duy nhất, được quản lý bởi component và được tái provide khi được request.</p><p>Trong trường hợp này, chúng ta sẽ gắn <code class="language-plaintext highlighter-rouge">DbHelper</code> vào <code class="language-plaintext highlighter-rouge">MainComponent</code> bằng cách sử dụng một <em>scope annotation</em> được <em>Dagger</em> định nghĩa trước: <code class="language-plaintext highlighter-rouge">@Singleton</code>. Các vị trí cần thêm <em>scope annotation</em> là:</p><ol><li>Component mà chúng ta muốn sử dụng scope:<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>@Singleton
@Component(modules = [UtilsModule::class, PresenterModule::class, RepositoryModule::class,  ApiModule::class])
interface MainComponent { ... }
</pre></table></code></div></div><li>Những class mà được thêm vào <em>dependency graph</em> bằng <code class="language-plaintext highlighter-rouge">@Inject</code>:<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>@Singleton
class ApiHelper @Inject constructor(var userService: MainService) { ... }
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>@Singleton
class PreferenceHelper @Inject constructor() { ... }
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>@Singleton
class DbHelper @Inject constructor() { ... }
</pre></table></code></div></div><li>Các provide function và bind function của các module gắn với component:<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>@Module
object RepositoryModule {

 @Provides
 @Singleton
 @JvmStatic
 fun provideMainRepository(mainRepositoryImpl: MainRepositoryImpl): MainRepository {
     return mainRepositoryImpl
 }

 @Provides
 @Singleton
 @JvmStatic
 fun provideLoginRepository(loginRepositoryImpl: LoginRepositoryImpl): LoginRepository {
     return loginRepositoryImpl
 }
}
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>@Module
abstract class PresenterModule {

 @Binds
 @Singleton
 abstract fun provideMainPresenter(mainPresenterImpl: MainPresenterImpl): MainPresenter

 @Binds
 @Singleton
 abstract fun provideLoginPresenter(loginPresenterImpl: LoginPresenterImpl): LoginPresenter
}
</pre></table></code></div></div></ol><p>Run project và kiểm tra lại kết quả. Voila! Chỉ có một instance duy nhất được tạo ra:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>2021-03-22 10:48:40.391 11937-11937/? I/System.out: io.srinnix.playground.dagger2.automatic.data.DbHelper@86bb88e
2021-03-22 10:48:40.391 11937-11937/? I/System.out: io.srinnix.playground.dagger2.automatic.data.DbHelper@86bb88e
</pre></table></code></div></div><p>Để chắc chắn hơn, chúng ta lại kiểm tra code mà <em>Dagger</em> gen ra:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>public final class DaggerMainComponent implements MainComponent {
    private Provider&lt;DbHelper&gt; dbHelperProvider;

    private DaggerMainComponent() {
      initialize();
    }

    private void initialize() {
        this.dbHelperProvider = DoubleCheck.provider(DbHelper_Factory.create());
    }

    private MainRepositoryImpl mainRepositoryImpl() {
        return new MainRepositoryImpl(apiHelper(), new PreferenceHelper(), dbHelperProvider.get());
    }

    private LoginRepositoryImpl loginRepositoryImpl() {
        return new LoginRepositoryImpl(apiHelper(), new PreferenceHelper(), dbHelperProvider.get());
    }
}
</pre></table></code></div></div><p>Chúng ta thấy rằng <code class="language-plaintext highlighter-rouge">dbHelperProvider</code> sẽ được khởi tạo một lần duy nhất khi <code class="language-plaintext highlighter-rouge">DaggerMainComponent</code> được khởi tạo. Và từ sau đó, mỗi khi cần <code class="language-plaintext highlighter-rouge">DbHelper</code>, <code class="language-plaintext highlighter-rouge">dbHelperProvider.get()</code> sẽ trả về một instance <code class="language-plaintext highlighter-rouge">DbHelper</code> duy nhất.</p><p><strong>Note:</strong></p><ul><li>Cái tên <em>Singleton</em> dễ làm chúng ta nhớ đến design pattern <em>Singleton</em> nên có thể gây hiểu nhầm rằng cứ sử dụng annotation này thì các dependency sẽ “sống” trong toàn bộ vòng đời của chương trình. Tuy nhiên, cần phải sửa lại và nhấn mạnh rằng: đây chỉ là một cái tên, <em>Dagger</em> không thể suy ra được vòng đời của dependency dựa vào ý nghĩa của cái tên đó. <em>Dagger</em> chỉ đơn giản dùng tên scope để quyết định xem: có nên provide một instance duy nhất (component có scope <strong>trùng</strong> với dependency) hay nên tạo ra thêm instance (component có scope <strong>khác</strong> với dependency).<li>Việc khởi tạo duy nhất 1 instance chỉ có tác dụng khi ta sử dụng chung component. Tức là nếu chúng ta khởi tạo 2 component ở 2 nơi (VD: <code class="language-plaintext highlighter-rouge">LoginActivity</code> và <code class="language-plaintext highlighter-rouge">MainActivity</code>), chúng ta vẫn sẽ có 2 bộ dependency khác nhau.</ul><p>Với yêu cầu là để <code class="language-plaintext highlighter-rouge">DbHelper</code> tồn tại trong suốt chương trình, chúng ta cần khởi tạo và keep component ở một chỗ - nơi có vòng đời bao trùm lên các Activity, thì khi dù cho các Activity được tạo ra hoặc chết đi, các dependency mong muốn vẫn sẽ tồn tại độc lập. Với <em>Android</em>, một chỗ phù hợp để keep các <em>global singleton dependency</em> kiểu này là <code class="language-plaintext highlighter-rouge">Application</code>. Cùng với việc chuyển đoạn code khai báo và khởi tạo component sang <code class="language-plaintext highlighter-rouge">Application</code>, chúng ta sẽ đổi tên component thành <code class="language-plaintext highlighter-rouge">ApplicationComponent</code> để đúng với context hiện tại hơn.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>class MyApplication : Application() {

    val applicationComponent: ApplicationComponent by lazy {
        return@lazy DaggerApplicationComponent.builder()
            .utilsModule(UtilsModule(applicationContext))
            .build()
    }
}
</pre></table></code></div></div><p>Và ở các activity, chúng ta sẽ lấy <code class="language-plaintext highlighter-rouge">DaggerApplicationComponent</code> từ <code class="language-plaintext highlighter-rouge">MyApplication</code> ra để inject thay vì khởi tạo mới:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>class LoginActivity : FragmentActivity() {
    ...

    override fun onCreate(savedInstanceState: Bundle?) {
        (application as? MyApplication)?.applicationComponent?.inject(this)
        ...
    }
}

class MainActivity : FragmentActivity() {
    ...

    override fun onCreate(savedInstanceState: Bundle?) {
        (application as? MyApplication)?.applicationComponent?.inject(this)
        ...
    }
}
</pre></table></code></div></div><p>Tuy nhiên, nếu gắn vòng đời <code class="language-plaintext highlighter-rouge">ApplicationComponent</code> vào <code class="language-plaintext highlighter-rouge">MyApplication</code>, những class như <code class="language-plaintext highlighter-rouge">MainPresenter</code>, <code class="language-plaintext highlighter-rouge">MainRepository</code>, <code class="language-plaintext highlighter-rouge">LoginPresenter</code>, <code class="language-plaintext highlighter-rouge">LoginRepository</code> sẽ tiếp tục tồn tại trong memory ngay cả sau khi các màn hình <code class="language-plaintext highlighter-rouge">MainActivity</code> và <code class="language-plaintext highlighter-rouge">LoginActivity</code> đóng. Thay vào đó, chúng ta muốn các instance sẽ được tạo mới mỗi khi một màn hình mới được mở lên. Để giải quyết vấn đề này, <em>Dagger</em> cho phép định nghĩa nhiều hơn một component (hay <em>dependency graph</em>) duy nhất. Chúng ta có thể chia <code class="language-plaintext highlighter-rouge">ApplicationComponent</code> thành các component nhỏ hơn để đóng gói các dependency có những điểm chung thành một component riêng. Các component nhỏ hơn này cũng sẽ có những scope riêng, đáp ứng đủ mọi loại yêu cầu về vòng đời của chúng ta.</p><h3 id="the-very-first-teenager-program">The very first “teenager” program</h3><p>Trước khi bắt tay vào implement scope, chúng ta sẽ tăng độ khó cho game để thấy rõ hơn sức mạnh của <em>Dagger</em>. Chương trình bây giờ sẽ gồm 4 màn hình như sau:</p><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/bew7c60zs3_Screenshot%20from%202021-04-12%2017-11-01.png" /></p><p>Flow của app sẽ như sau:</p><ul><li>Ở màn hình <code class="language-plaintext highlighter-rouge">LoginActivity</code>, user sẽ nhập username và password để login<li>Sau khi login thành công, màn <code class="language-plaintext highlighter-rouge">MainActivity</code> sẽ mở lên và hiển thị số thông báo chưa đọc<li>Nếu user click vào button Settings, màn <code class="language-plaintext highlighter-rouge">SettingsActivity</code> sẽ mở lên. Ở đây, chúng ta có:<ul><li>Button Refresh để mô tả việc refresh và lấy về số notification chưa đọc và hiển thị lên.<li>Button Logout để logout user và trở về màn <code class="language-plaintext highlighter-rouge">LoginActivity</code></ul><li>Khi quay về màn <code class="language-plaintext highlighter-rouge">MainActivity</code>, số notification chưa đọc ở đây được update tương ứng với màn <code class="language-plaintext highlighter-rouge">SettingsActivity</code>.</ul><p>Ngoài ra, phần data của app sẽ có thêm một sự thay đổi khi chúng ta sẽ có thêm một class <code class="language-plaintext highlighter-rouge">UserManager</code> như một dạng memory cache, giữ thông tin của user (<code class="language-plaintext highlighter-rouge">LoggedUserInfo</code>) sau khi đăng nhập thành công.</p><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/p6w8tr7sjn_DaggerScope.jpg" /></p><p>Với requrirement như trên, chúng ta có thể chia các dependency vào 3 nhóm như sau với vòng đời tương ứng như sau:</p><ol><li>Nhóm application: những class chúng ta chỉ muốn tạo một lần và sẽ được tái sử dụng trong suốt ứng dụng. Đó là <code class="language-plaintext highlighter-rouge">Context</code>(Application context), <code class="language-plaintext highlighter-rouge">ApiHelper</code>, <code class="language-plaintext highlighter-rouge">PreferenceHelper</code>, <code class="language-plaintext highlighter-rouge">DbHelper</code> và <code class="language-plaintext highlighter-rouge">UernManager</code><li>Nhóm user info: những class sẽ tồn tại khi user login thành công và chỉ bị hủy khi user logout. VD: <code class="language-plaintext highlighter-rouge">LoggedUserInfo</code> nằm trong <code class="language-plaintext highlighter-rouge">UserManager</code><li>Nhóm activity: những class sẽ được khởi tạo khi màn hình được mở lên và hủy khi màn hình đóng: <code class="language-plaintext highlighter-rouge">MainPresenter</code>, <code class="language-plaintext highlighter-rouge">MainRepository</code>, <code class="language-plaintext highlighter-rouge">LoginPresenter</code>, <code class="language-plaintext highlighter-rouge">LoginRepository</code>…</ol><p>Vòng đời của ba nhóm này được mô hình hóa rõ hơn ở biểu đó dưới đây:</p><p align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/m8o540amyn_application_lifecycle.jpg" /></p><p><strong>Note:</strong> <code class="language-plaintext highlighter-rouge">UserManager</code> sẽ “sống” trong suốt chương trình nhưng <code class="language-plaintext highlighter-rouge">LoggedUserInfo</code> chỉ có mặt sau khi user đã login thành công.</p><p>Từ mô hình về application lifecycle ở trên, chúng ta sẽ tạo ra thêm 2 component để quản lý các dependency với vòng đời tương ứng: <code class="language-plaintext highlighter-rouge">UserComponent</code> và <code class="language-plaintext highlighter-rouge">ActivityComponent</code></p><h5 id="usercomponent">UserComponent</h5><p><code class="language-plaintext highlighter-rouge">UserComponent</code> sẽ được khởi tạo sau khi đăng nhập thành công và sẽ tiếp tục tồn tại cho đến khi đóng chương trình hoặc user logout. Vì vậy, trách nhiệm quản lý dependency cho các màn hình xuất hiện sau khi login thành công (<code class="language-plaintext highlighter-rouge">MainActivity</code> và <code class="language-plaintext highlighter-rouge">SettingsActivity</code>) nên là của <code class="language-plaintext highlighter-rouge">UserComponent</code> thay vì <code class="language-plaintext highlighter-rouge">ApplicationComponent</code> vì nó thể hiện đúng hơn vòng đời của các dependency. Ngoài ra, việc này giúp giảm tải cho <code class="language-plaintext highlighter-rouge">ApplicationComponent</code>, làm code được module hóa và dễ đọc hơn.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>@Component
interface UserComponent {

    fun inject(mainActivity: MainActivity)

    fun inject(settingsActivity: SettingsActivity)
}
</pre></table></code></div></div><p>Cùng với <code class="language-plaintext highlighter-rouge">UserComponent</code>, chúng ta cần tạo thêm một <em>scope annotation</em> tương ứng để:</p><ul><li>Phân biệt giữa các component dễ dàng hơn bởi <em>scope annotation</em> sẽ thể hiện phạm vi của component<li>Sử dụng với những dependency mà chúng ta muốn nó chỉ có 1 instance duy nhất trong suốt vòng đời của component.</ul><p>Annotation tương ứng với <code class="language-plaintext highlighter-rouge">UserComponent</code> sẽ là <code class="language-plaintext highlighter-rouge">@LoggedUserScope</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>@Scope
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class LoggedUserScope
</pre></table></code></div></div><p><strong>Note:</strong> Về việc tạo <em>scope annotation</em>, chúng ta có thể copy <code class="language-plaintext highlighter-rouge">@Singleton</code> và đổi tên là xong.</p><p>Sau khi khai báo component, chúng ta cần xác định việc nên giữ component ở đâu, khởi tạo và giải phóng component lúc nào để đảm bảo rằng các dependency mà component đó quản lý sẽ có vòng đời đúng như chúng ta mong muốn. Với <code class="language-plaintext highlighter-rouge">UserComponent</code>, câu trả lời cho 3 câu hỏi vừa rồi là:</p><ul><li>Lưu <code class="language-plaintext highlighter-rouge">UserComponent</code> ở đâu? Không thể lưu ở Activity vì khi Activity “đứt” thì <code class="language-plaintext highlighter-rouge">UserComponent</code> cũng “đứt” theo. Bởi vậy, chúng ta cần lưu ở một chỗ nào có vòng đời bao trùm các Activity. <code class="language-plaintext highlighter-rouge">Application</code> thì sao? Về mặt kỹ thuật thì hoàn toàn được, object này rõ ràng là đáp ứng được yêu cầu của chúng ta khi sẽ sống đủ lâu. Tuy nhiên, việc lưu <code class="language-plaintext highlighter-rouge">UserComponent</code> vào <code class="language-plaintext highlighter-rouge">Application</code> không hợp lý lắm về mặt cấu trúc vì <code class="language-plaintext highlighter-rouge">UserComponent</code> sẽ quản lý những dependency liên quan đến user cơ. Bởi vậy, một class đã có sẵn khác đáp ứng được cả 2 yêu cầu trên là <code class="language-plaintext highlighter-rouge">UserManager</code><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>@Singleton
class UserManager @Inject constructor() {

var userComponent: UserComponent? = null

fun isUserLoggedIn() = userComponent != null
}
</pre></table></code></div></div><li>Khởi tạo và giải phóng <code class="language-plaintext highlighter-rouge">UserComponent</code> lúc nào? Chúng ta cần <code class="language-plaintext highlighter-rouge">UserComponent</code> để inject ở các màn hình sau khi đăng nhập thành công và sẽ không cần <code class="language-plaintext highlighter-rouge">UserComponent</code> nữa khi logout. Bởi vậy, chúng ta sẽ tạo ra 2 method bên trong <code class="language-plaintext highlighter-rouge">UserManager</code> để khởi tạo và giải phóng <code class="language-plaintext highlighter-rouge">UserComponent</code><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>fun login(username: String, password: String): Boolean {
  initUserComponent(username)
  return true
}
fun logout() {
  userComponent = null
}
private fun initUserComponent(userName: String) {
  userComponent =  DaggerUserComponent.builder().build()
}
</pre></table></code></div></div></ul><h5 id="activitycomponent">ActivityComponent</h5><p>Dựa vào tên của component, chúng ta có thể đoán ra component này sẽ gắn đời mình với các activity: activity được mở lên thì component cũng được khởi tạo còn khi activity bị hủy thì component cũng được giải phóng theo. Các activity nằm dưới trách nhiệm của <code class="language-plaintext highlighter-rouge">ActivityComponent</code> là <code class="language-plaintext highlighter-rouge">LoginActivity</code>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>@Component
interface ActivityComponent {

    fun inject(loginActivity: LoginActivity)
}
</pre></table></code></div></div><p>Annotation tương ứng sẽ là <code class="language-plaintext highlighter-rouge">@ActivityScope</code></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>@Scope
@MustBeDocumented
@kotlin.annotation.Retention(AnnotationRetention.RUNTIME)
annotation class ActivityScope
</pre></table></code></div></div><p>Tương tự như với <code class="language-plaintext highlighter-rouge">UserComponent</code>, chúng ta phải trả lời 3 câu hỏi: lưu ở đâu, khởi tạo và giải phóng lúc nào. Tuy nhiên, vì component này được gắn vào các Activity nên 3 vấn đề kia cũng trở nên dễ dàng hơn. Cụ thể là</p><ul><li>Chúng ta sẽ lưu <code class="language-plaintext highlighter-rouge">ActivityComponent</code> ở chính các Activity. Lưu ý: Mỗi activity sẽ có một component riêng để với mỗi màn hình, chúng ta cũng sẽ có một bộ dependency riêng.<li>Chúng ta sẽ khởi tạo component ở <code class="language-plaintext highlighter-rouge">onCreate()</code> và có thể bỏ qua khoản giải phóng vì khi Activity đóng thì component cũng sẽ được giải phóng theo.</ul><h1 id="cùng-nhìn-lại">Cùng nhìn lại</h1><p>Vậy là khi chương trình “trưởng thành” hơn với những yêu cầu về vòng đời của các dependency phức tạp hơn, chúng ta đã chia nhỏ “god component” ban đầu ra thành các component nhỏ hơn để quản lý các dependency được chính xác hơn. Tuy nhiên, chương trình của chúng ta vẫn chưa thể chạy vì khi đã chia các component ra, chúng ta cần giải quyết thêm vấn đề giao tiếp giữa các component để đến cuối cùng, một <em>dependency graph</em> của cả chương trình vẫn được vẽ ra dựa trên sự kết hợp hài hòa của các <em>dependency graph</em> nhỏ hơn. Phần tiếp theo của series sẽ hoàn thành bức tranh lớn ấy.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >android</a> <a href="/tags/dependency-injection/" class="post-tag no-text-decoration" >dependency injection</a> <a href="/tags/dagger/" class="post-tag no-text-decoration" >dagger</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Android] Dagger 2 - Phần III - 1: The time of our dependencies - srinnix13&url=https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Android] Dagger 2 - Phần III - 1: The time of our dependencies - srinnix13&u=https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Android] Dagger 2 - Phần III - 1: The time of our dependencies - srinnix13&url=https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://srinnix1395.github.io/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-IV/">[Android] Dagger 2 - Phần IV: A new horizon</a><li><a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-I/">[Android] Dagger 2 - Phần I: Basic principles</a><li><a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-II/">[Android] Dagger 2 - Phần II: Into the Dagger 2</a><li><a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/">[Android] Dagger 2 - Phần III - 1: The time of our dependencies</a><li><a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-2/">[Android] Dagger 2 - Phần III - 2: The time of our dependencies</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/dagger/">dagger</a> <a class="post-tag" href="/tags/dependency-injection/">dependency injection</a> <a class="post-tag" href="/tags/bitmap/">bitmap</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/image/">image</a> <a class="post-tag" href="/tags/layout/">layout</a> <a class="post-tag" href="/tags/recyclerview/">recyclerview</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-I/"><div class="card-body"> <span class="timeago small" > Apr 20 <i class="unloaded">2021-04-20T07:42:01+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] Dagger 2 - Phần I: Basic principles</h3><div class="text-muted small"><p> Mình biết đến Dagger (chính xác là Dagger 2) khi còn đi thực tập ở một công ty. Vì chỉ là một android intern làm việc 4 tiếng một ngày nên công việc chính của mình chỉ là fix một vài cái issue bé b...</p></div></div></a></div><div class="card"> <a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-II/"><div class="card-body"> <span class="timeago small" > Apr 20 <i class="unloaded">2021-04-20T07:42:02+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] Dagger 2 - Phần II: Into the Dagger 2</h3><div class="text-muted small"><p> Bài viết là phần thứ II của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc phần trước, bạn có thể ghi danh vào lớp học tại đây Các bài học để lên lớp [Android] Dagger 2 - Phần I: Basic p...</p></div></div></a></div><div class="card"> <a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-2/"><div class="card-body"> <span class="timeago small" > Apr 20 <i class="unloaded">2021-04-20T07:42:04+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] Dagger 2 - Phần III - 2: The time of our dependencies</h3><div class="text-muted small"><p> Bài viết là phần thứ III của series bài học vỡ lòng về Dagger 2. Nếu bạn chưa đọc các phần trước, bạn có thể ghi danh vào lớp học tại đây Các bài học để lên lớp [Android] Dagger 2 - Phần I: Ba...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-II/" class="btn btn-outline-primary" prompt="Older"><p>[Android] Dagger 2 - Phần II: Into the Dagger 2</p></a> <a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-2/" class="btn btn-outline-primary" prompt="Newer"><p>[Android] Dagger 2 - Phần III - 2: The time of our dependencies</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/srinnix13">tuha3</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/dagger/">dagger</a> <a class="post-tag" href="/tags/dependency-injection/">dependency injection</a> <a class="post-tag" href="/tags/bitmap/">bitmap</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/image/">image</a> <a class="post-tag" href="/tags/layout/">layout</a> <a class="post-tag" href="/tags/recyclerview/">recyclerview</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://srinnix1395.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
