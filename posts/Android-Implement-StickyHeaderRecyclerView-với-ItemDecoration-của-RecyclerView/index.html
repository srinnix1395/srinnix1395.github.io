<!DOCTYPE html><html lang="en-US" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="[Android] Implement StickyHeaderRecyclerView với ItemDecoration của RecyclerView" /><meta property="og:locale" content="en_US" /><meta name="description" content="Tại Google I/O 2014, cùng với sự ra mắt của Android Lollipop, Google đã giới thiệu RecyclerView - a better ListView với nhiều cải tiến cho phép gia tăng hiệu năng, đồng thời giải quyết nhiều vấn đề tồn tại của phiên bản ListView cũ. Khi nói đến RecyclerView, chúng ta có thể nhắc đến một số khái niệm mới: ViewHolder (pattern này cho phép tăng performance và vẫn có thể sử dụng được với ListView tuy nhiên không bắt buộc), LayoutManager, ItemDecoration và ItemAnimator. Đây đều là những chức năng người dùng có thể sử dụng RecyclerView để giải quyết những bài toán phức tạp hơn so với ListView hay GridView ngày xưa có thể làm được. Trong bài viết hôm nay, mình xin chia sẻ một chút về ItemDecoration, một tính năng hầu hết không được các dev sử dụng vì có thể các dev vẫn quen với tư duy của ListView cũ hoặc chưa thấy được hết sức mạnh mà ItemDecoration có thể mang lại." /><meta property="og:description" content="Tại Google I/O 2014, cùng với sự ra mắt của Android Lollipop, Google đã giới thiệu RecyclerView - a better ListView với nhiều cải tiến cho phép gia tăng hiệu năng, đồng thời giải quyết nhiều vấn đề tồn tại của phiên bản ListView cũ. Khi nói đến RecyclerView, chúng ta có thể nhắc đến một số khái niệm mới: ViewHolder (pattern này cho phép tăng performance và vẫn có thể sử dụng được với ListView tuy nhiên không bắt buộc), LayoutManager, ItemDecoration và ItemAnimator. Đây đều là những chức năng người dùng có thể sử dụng RecyclerView để giải quyết những bài toán phức tạp hơn so với ListView hay GridView ngày xưa có thể làm được. Trong bài viết hôm nay, mình xin chia sẻ một chút về ItemDecoration, một tính năng hầu hết không được các dev sử dụng vì có thể các dev vẫn quen với tư duy của ListView cũ hoặc chưa thấy được hết sức mạnh mà ItemDecoration có thể mang lại." /><link rel="canonical" href="https://srinnix1395.github.io/posts/Android-Implement-StickyHeaderRecyclerView-v%E1%BB%9Bi-ItemDecoration-c%E1%BB%A7a-RecyclerView/" /><meta property="og:url" content="https://srinnix1395.github.io/posts/Android-Implement-StickyHeaderRecyclerView-v%E1%BB%9Bi-ItemDecoration-c%E1%BB%A7a-RecyclerView/" /><meta property="og:site_name" content="srinnix13" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-03-12T07:42:03+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Android] Implement StickyHeaderRecyclerView với ItemDecoration của RecyclerView" /><meta name="twitter:site" content="@srinnix13" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Tại Google I/O 2014, cùng với sự ra mắt của Android Lollipop, Google đã giới thiệu RecyclerView - a better ListView với nhiều cải tiến cho phép gia tăng hiệu năng, đồng thời giải quyết nhiều vấn đề tồn tại của phiên bản ListView cũ. Khi nói đến RecyclerView, chúng ta có thể nhắc đến một số khái niệm mới: ViewHolder (pattern này cho phép tăng performance và vẫn có thể sử dụng được với ListView tuy nhiên không bắt buộc), LayoutManager, ItemDecoration và ItemAnimator. Đây đều là những chức năng người dùng có thể sử dụng RecyclerView để giải quyết những bài toán phức tạp hơn so với ListView hay GridView ngày xưa có thể làm được. Trong bài viết hôm nay, mình xin chia sẻ một chút về ItemDecoration, một tính năng hầu hết không được các dev sử dụng vì có thể các dev vẫn quen với tư duy của ListView cũ hoặc chưa thấy được hết sức mạnh mà ItemDecoration có thể mang lại.","headline":"[Android] Implement StickyHeaderRecyclerView với ItemDecoration của RecyclerView","dateModified":"2021-04-20T09:10:36+00:00","datePublished":"2018-03-12T07:42:03+00:00","url":"https://srinnix1395.github.io/posts/Android-Implement-StickyHeaderRecyclerView-v%E1%BB%9Bi-ItemDecoration-c%E1%BB%A7a-RecyclerView/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://srinnix1395.github.io/posts/Android-Implement-StickyHeaderRecyclerView-v%E1%BB%9Bi-ItemDecoration-c%E1%BB%A7a-RecyclerView/"},"@context":"https://schema.org"}</script><title>[Android] Implement StickyHeaderRecyclerView với ItemDecoration của RecyclerView | srinnix13</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/resources/github_avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">srinnix13</a></div><div class="site-subtitle font-italic">The man who is looking for an olive branch and a piece of cheese, of course!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/srinnix1395" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/srinnix13" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/srinnix13" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['srinnix13','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[Android] Implement StickyHeaderRecyclerView với ItemDecoration của RecyclerView</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Android] Implement StickyHeaderRecyclerView với ItemDecoration của RecyclerView</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> tuha3 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Mar 12, 2018, 7:42 AM +0000" prep="on" > Mar 12, 2018 <i class="unloaded">2018-03-12T07:42:03+00:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Apr 20, 2021, 4:10 PM +0700" prefix="Updated " > Apr 20 <i class="unloaded">2021-04-20T09:10:36+00:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2810 words">15 min</span></div></div><div class="post-content"><p>Tại Google I/O 2014, cùng với sự ra mắt của Android Lollipop, Google đã giới thiệu <code class="language-plaintext highlighter-rouge">RecyclerView</code> - <em>a better ListView</em> với nhiều cải tiến cho phép gia tăng hiệu năng, đồng thời giải quyết nhiều vấn đề tồn tại của phiên bản <code class="language-plaintext highlighter-rouge">ListView</code> cũ. Khi nói đến <code class="language-plaintext highlighter-rouge">RecyclerView</code>, chúng ta có thể nhắc đến một số khái niệm mới: <code class="language-plaintext highlighter-rouge">ViewHolder</code> (pattern này cho phép tăng performance và vẫn có thể sử dụng được với <code class="language-plaintext highlighter-rouge">ListView</code> tuy nhiên không bắt buộc), <code class="language-plaintext highlighter-rouge">LayoutManager</code>, <code class="language-plaintext highlighter-rouge">ItemDecoration</code> và <code class="language-plaintext highlighter-rouge">ItemAnimator</code>. Đây đều là những chức năng người dùng có thể sử dụng <code class="language-plaintext highlighter-rouge">RecyclerView</code> để giải quyết những bài toán phức tạp hơn so với <code class="language-plaintext highlighter-rouge">ListView</code> hay <code class="language-plaintext highlighter-rouge">GridView</code> ngày xưa có thể làm được. Trong bài viết hôm nay, mình xin chia sẻ một chút về <code class="language-plaintext highlighter-rouge">ItemDecoration</code>, một tính năng hầu hết không được các dev sử dụng vì có thể các dev vẫn quen với tư duy của <code class="language-plaintext highlighter-rouge">ListView</code> cũ hoặc chưa thấy được hết sức mạnh mà <code class="language-plaintext highlighter-rouge">ItemDecoration</code> có thể mang lại.</p><p>Trong khuôn khổ bài viết này, mình sẽ viết code bằng <code class="language-plaintext highlighter-rouge">Kotlin</code>, một ngôn ngữ được Google chính thức support từ Google I/O 2017. Nếu kết thúc năm 2017, bạn vẫn đang trì hoãn rằng mình sẽ học <code class="language-plaintext highlighter-rouge">Kotlin</code>, mình sẽ học <code class="language-plaintext highlighter-rouge">Kotlin</code>… Để mình nhắc lại rằng: hiện tại là năm 2018 rồi, đừng là kẻ trì hoãn nữa (như mình), học đi hoặc không bao giờ. Và có thể khi bạn bối rối không biết bắt đầu từ đâu, <a href="https://github.com/ngohado/Kotlin-Docs">repo</a> này sẽ là một bước giúp bạn rõ hơn về những cú pháp cơ bản của <code class="language-plaintext highlighter-rouge">Kotlin</code>. Good luck!</p><h1 id="giới-thiệu">Giới thiệu</h1><p>Đầu tiên, theo doc chính thức của <em>Android</em>:</p><blockquote><p>An ItemDecoration allows the application to add a special drawing and layout offset to specific item views from the adapter’s data set. This can be useful for drawing dividers between items, highlights, visual grouping boundaries and more.</p></blockquote><p>Nói một cách đơn giản, <code class="language-plaintext highlighter-rouge">ItemDecoration</code> là một công cụ dùng để decor các item trong <code class="language-plaintext highlighter-rouge">RecyclerView</code>. Bài viết hôm nay sẽ đi qua một số task mà chúng ta có thể sử dụng <code class="language-plaintext highlighter-rouge">ItemDecoration</code> để hoàn thành.</p><h1 id="spacing">Spacing</h1><p>Với <code class="language-plaintext highlighter-rouge">ListView</code> ngày xưa, để ngăn cách giữa các item, bạn có thể sử dụng thuộc tính của ListView ngay trong file layout:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>  &lt;ListView
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:divider="@android:color/black"
      android:dividerHeight="2dp" /&gt;
</pre></table></code></div></div><p>Tuy nhiên, với <code class="language-plaintext highlighter-rouge">RecyclerView</code>, chúng ta sẽ không thể thêm trực tiếp divider mà phải sử dụng <code class="language-plaintext highlighter-rouge">ItemDecoration</code> để vẽ divider, và có lẽ các dev nghĩ rằng nó khá là rắc rối. Mình cũng vậy, trước khi biết <code class="language-plaintext highlighter-rouge">ItemDecoration</code>, thường để ngăn cách các item trong một list một khoảng 16dp, mình sẽ thường làm thế này: sử dụng marginBottom với chính item, đồng thời để paddingTop = 16dp và clipToPadding = false với <code class="language-plaintext highlighter-rouge">RecyclerView</code>. Cách làm này khá nhanh, tuy nhiên với một trường hợp phức tạo hơn: một list hiển thị dạng grid với 3 cột như <em>Instagram</em> này chẳng hạn:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/yps0gthadt_Screenshot_2018-01-22-14-33-52.png" alt="alt text" /></p><p>Với cách làm như ở trên, bạn sẽ phải dựa vào position của từng item mà set margin sao cho phù hợp: item số 0, 3, 6… phải marginEnd, item 2, 5, 8… phải marginStart rồi set lại <code class="language-plaintext highlighter-rouge">LayoutParams</code> trong <code class="language-plaintext highlighter-rouge">ViewHolder</code>, vân vân và mây mây. Tuy nhiên, cách làm này sẽ mất khá nhiều effort. Với <code class="language-plaintext highlighter-rouge">ItemDecoration</code>, việc ngăn cách các item được làm một cách tổng quát hơn, hoàn toàn không liên quan gì đến layout của từng item.</p><p>Để bắt đầu với <code class="language-plaintext highlighter-rouge">ItemDecoration</code>, bạn cần tạo một class kế thừa từ <code class="language-plaintext highlighter-rouge">ItemDecoration</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre>  class GridSpacingDecoration(private val spacing: Int,
                              private val spanCount: Int) : RecyclerView.ItemDecoration() {

    override fun getItemOffsets(outRect: Rect?, view: View?, parent: RecyclerView?, state: RecyclerView.State?) {
        val position = parent.getChildAdapterPosition(view)
        val column = position % 3 // item column

        outRect.left = column * spacing / spanCount
        outRect.right = spacing - (column + 1) * spacing / spanCount
        if (position &gt;= spanCount) {
            outRect.top = spacing
        }
    }

    override fun onDraw(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {
        super.onDraw(c, parent, state)
        //do nothing
    }

    override fun onDrawOver(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {
        super.onDrawOver(c, parent, state)
        //do nothing
    }
  }
</pre></table></code></div></div><p>Chúng ta cần quan tâm đến 3 method khi implement <code class="language-plaintext highlighter-rouge">ItemDecoration</code>, đó là: <code class="language-plaintext highlighter-rouge">getItemOffsets</code>, <code class="language-plaintext highlighter-rouge">onDraw</code> và <code class="language-plaintext highlighter-rouge">onDrawOver</code>. Với 3 method, có lẽ 2 mehod sau đã có tên khá là tự giải thích cho chức năng của nó (vẽ và vẽ lên trên - nôm na là như thế :v).</p><p>Với method đầu tiên, method này chính là công cụ cho phép ngăn cách các item trong một list. Và đó cũng chính là cách để chúng ta giải quyết bài toán ở trên. Mình sẽ giải thích method này hoạt động như thế nào: với từng item, method này sẽ được gọi nhằm mục đích setup khoảng ngăn cách cho mỗi item (tương tự như <code class="language-plaintext highlighter-rouge">padding</code> hay <code class="language-plaintext highlighter-rouge">margin</code>). Đại diện cho mỗi item ở đây là <code class="language-plaintext highlighter-rouge">outRect</code> với mỗi chiều của <code class="language-plaintext highlighter-rouge">outRect</code> sẽ là khoảng cách theo các chiều của item (left, top, right, bottom) và đơn vị của các chiều ở đây là px. Mặc định, khi không được <code class="language-plaintext highlighter-rouge">override</code> lại, 4 chiều giá trị của <code class="language-plaintext highlighter-rouge">outRect</code> sẽ được set bằng 0. Bởi vậy, để ngăn cách từng item, chúng ta phải dựa vào vị trí của từng item mà set các chiều tương ứng. Nếu bạn cần xác định vị trí của item đó trong adapter, chúng ta có thể gọi <code class="language-plaintext highlighter-rouge">getChildAdapterPosition(View)</code>.</p><p>Và cuối cùng, sau khi implement, ta sẽ thêm <code class="language-plaintext highlighter-rouge">ItemDecoration</code> cho <code class="language-plaintext highlighter-rouge">RecyclerView</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  rv.addItemDecoration(GridSpacingDecoration(2, (layoutManager as GridLayoutManager).spanCount))
</pre></table></code></div></div><p>Run thử phát cho nó lung linh:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/n7lt8tnld7_Screenshot_2018-01-22-13-25-43.png" alt="alt text" /></p><h1 id="divider">Divider</h1><p>Để có cách divider ngăn cách các item, bạn thường làm thế nào?</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre>  &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:tools="http://schemas.android.com/tools"
      android:layout_width="match_parent"
      android:layout_height="56dp"
      android:orientation="vertical"
      android:paddingEnd="0dp"
      android:paddingStart="16dp"&gt;

      &lt;LinearLayout
          android:layout_width="match_parent"
          android:layout_height="55dp"
          android:gravity="center_vertical"&gt;

          &lt;ImageView
              android:layout_width="44dp"
              android:layout_height="44dp"
              tools:src="@tools:sample/avatars" /&gt;

          &lt;TextView
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:layout_marginStart="8dp"
              tools:text="@tools:sample/full_names" /&gt;
      &lt;/LinearLayout&gt;

      &lt;View
          android:layout_width="match_parent"
          android:layout_height="1dp"
          android:background="@android:color/darker_gray" /&gt;

  &lt;/LinearLayout&gt;
</pre></table></code></div></div><p>Các dev nhà mình thường sẽ thêm ngay một <code class="language-plaintext highlighter-rouge">View</code> vào dưới cùng của layout, set độ cao, màu… Và tất nhiên, cách làm ngắn gọn này sẽ có những tác dụng phụ. Một tác dụng phụ dễ thấy nhất là sẽ tăng thêm độ sâu cho layout (<em>layout hierarchy</em>, trong trường hợp này là 2 thay vì 1), đồng thời làm tăng số lượng <code class="language-plaintext highlighter-rouge">View</code> lên một cách không cần thiết. Ngoài ra, bạn sẽ khó control các divider hơn nếu chúng là một phần của từng <code class="language-plaintext highlighter-rouge">View</code> (bạn phải dựa vào position, data để setup divider tùy theo), và điều đó hoàn toàn không flexible chút nào. And <code class="language-plaintext highlighter-rouge">ItemDecoration</code> to the rescue!!!</p><p>Ở đây, bạn cần tìm hiểu tiếp một method nữa đã được đề cập đến ở trên: <code class="language-plaintext highlighter-rouge">onDraw</code>. Method này dùng để vẽ những gì bạn muốn decor cho <code class="language-plaintext highlighter-rouge">RecyclerView</code>. Tuy nhiên hãy lưu ý rằng, đoạn vẽ này sẽ được vẽ trước khi <code class="language-plaintext highlighter-rouge">RecyclerView</code> vẽ các item trong list. Nếu muốn vẽ lên trên, hãy kiên nhẫn đọc tiếp đến (hoặc bỏ qua phần này kéo đến) phần sau.</p><p>Chúng ta sẽ tạo một class kế thừa từ <code class="language-plaintext highlighter-rouge">ItemDecoration</code> như phần trên:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre>  class SeparatorDecoration (context: Context, orientation: Int) : RecyclerView.ItemDecoration() {

    companion object {
        const val HORIZONTAL = LinearLayout.HORIZONTAL
        const val VERTICAL = LinearLayout.VERTICAL
    }

    private var mDivider: Drawable? = null

    private var mOrientation: Int = LinearLayout.VERTICAL

    fun setOrientation(orientation: Int) {
        mOrientation = orientation
    }

    fun setDrawable(drawable: Drawable?) {
        mDivider = drawable
    }

    override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State?) {
        //todo
    }

    override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {
        //todo
    }
  }
</pre></table></code></div></div><p>Ở đây chúng ta có 2 method cần phải implement: <code class="language-plaintext highlighter-rouge">getItemOffsets</code> để ngăn cách các item ra một khoảng đúng bằng độ cao của divider, và <code class="language-plaintext highlighter-rouge">onDraw</code> sẽ vẽ divider tương ứng. Mình sẽ implement cho <code class="language-plaintext highlighter-rouge">LinearLayoutManager</code> vertical, phần horizontal cũng sẽ là tương tự.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>  override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {
      if (mOrientation == VERTICAL) {
          outRect.set(0, 0, 0, mDivider!!.intrinsicHeight)
      } else { //HORIZONTAL
          //todo
      }
  }
</pre></table></code></div></div><p>Và với <code class="language-plaintext highlighter-rouge">onDraw</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre>  override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State?) {
      if (mOrientation == VERTICAL) {
          drawVertical(c, parent)
      } else { //HORIZONTAL
          //todo
      }
  }

  private fun drawVertical(canvas: Canvas, parent: RecyclerView) {
      val bounds = Rect()

      canvas.save()
      var left: Int
      var right: Int

      val paddingRect = mDivider!!.getPadding()
      val paddingLeftDrawable = paddingRect.left
      val paddingRightDrawable = paddingRect.right

      if (parent.clipToPadding) {
          left = parent.paddingLeft
          right = parent.width - parent.paddingRight
          canvas.clipRect(left, parent.paddingTop, right, parent.height - parent.paddingBottom)
      } else {
          left = 0
          right = parent.width
      }

      left += paddingLeftDrawable
      right -= paddingRightDrawable

      val childCount = parent.childCount
      for (i in 0 until childCount) {
          val child = parent.getChildAt(i)
          val bottom = bounds.bottom
          val top = bottom - mDivider!!.intrinsicHeight
          mDivider!!.setBounds(left, top, right, bottom)
          mDivider!!.draw(canvas)
      }
      canvas.restore()
  }
</pre></table></code></div></div><p>Nhìn có vẻ hơi lằng nhằng, nhưng ở đây, việc cần làm là: lấy padding của drawable divider, padding của <code class="language-plaintext highlighter-rouge">RecyclerView</code>, margin của từng item. Sau đó tính toán dài rộng của divider. Và cuối cùng, gọi thằng canvas vẽ là xong. Khi đã hiểu cách tạo ra divider bằng <code class="language-plaintext highlighter-rouge">ItemDecoration</code>, chúng ta có thể sử dụng một class được Google cung cấp sẵn: <code class="language-plaintext highlighter-rouge">DividerItemDecoration</code> - bạn cần truyền vào orientation và drawable:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>  rvOption.apply {
      val divider = DividerItemDecoration(context, SeparatorDecoration.VERTICAL).apply {
          setDrawable(ContextCompat.getDrawable(context, R.drawable.divider))
      }
      addItemDecoration(divider)
  }
</pre></table></code></div></div><p>Bạn có thể nghĩ thầm: “Sao không phang cha <code class="language-plaintext highlighter-rouge">DividerItemDecoration</code> ngay từ đầu có phải nhanh không~~”. Tuy nhiên, việc bạn hiểu một lib hoạt động như thế nào hoặc hơn nữa là cách để tạo ra lib đó sẽ tốt hơn cho kiến thức của bạn rất nhiều. Hãy là một lập trình viên chịu tìm hiểu, đừng là một kẻ ăn sẵn.</p><h1 id="stickyheaderrecyclerview">StickyHeaderRecyclerView</h1><p>Phù, vậy là mình đã đi qua 2 method đầu tiên, đây là phần mình sẽ nói về method còn lại: <code class="language-plaintext highlighter-rouge">onDrawOver</code>. Thực ra, method này chỉ khác method <code class="language-plaintext highlighter-rouge">onDraw</code> một xíu: đó là method này được gọi sau khi các item được vẽ, bởi vậy những thứ bạn vẽ thông qua method này sẽ nằm phía trên các item, thay vì nằm phía dưới như method <code class="language-plaintext highlighter-rouge">onDraw</code> (được vẽ trước khi các item được vẽ). Được rồi, chúng ta sẽ tận dụng điều này để implement một function mà các dev thường phải sử dụng một lib bên ngoài. Đó là <em>StickyHeaderRecyclerView</em>.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hph1m2ku5a_stickyheader.gif" alt="alt text" /></p><p>Chúng ta sẽ phân tích một chút những việc sẽ làm: chúng ta sẽ vẽ một header, và nội dung của header (hoặc design của header sẽ tùy thuộc vào vị trí của item). Bởi vậy, ta sẽ để người dùng trả về những giá trị sau:</p><ul><li>Position của header của một item bấy kỳ là gì?<li>Layout của header để có thể inflate và draw<li>Không phải trả về, nhưng người dùng cần bindData cho từng header tương ứng<li>Liệu item này có phải là header hay không, phục vụ việc dịch chuyển header trước khi gặp một header mới</ul><p>Từ đó, ta sẽ tạo một interface để người dùng thực hiện những điều trên</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>   interface StickyHeaderInterface {

        fun getHeaderPositionForItem(itemPosition: Int): Int

        fun getHeaderLayout(headerPosition: Int): Int

        fun bindHeaderData(header: TextView, headerPosition: Int)

        fun isHeader(itemPosition: Int): Boolean
   }
</pre></table></code></div></div><p>Tiếp theo, phần cốt yếu, để header mới đẩy header cũ lên trên khi 2 header tiếp xúc với nhau là ban đầu khi 2 header chưa tiếp xúc với nhau, header đang được stick sẽ được vẽ ở trên cùng của <code class="language-plaintext highlighter-rouge">RecyclerView</code>. Đến khi 2 header tiếp xúc với nhau, header cũ cần được vẽ lùi lên phía trên tùy theo vị trí của header mới, khi đó header cũ sẽ khuất dần cho đến khi header mới chiếm hoàn toàn vị trí của header cũ. Cứ như vậy, ta sẽ có cảm giác header được stick lên phía trên của <code class="language-plaintext highlighter-rouge">RecyclerView</code>.</p><p>Như vậy, ta cần 2 method để vẽ trong 2 trường hợp:</p><ul><li>Trường hợp 2 header không tiếp xúc với nhau, ta vẽ header được stick lên trên cùng của <code class="language-plaintext highlighter-rouge">RecyclerView</code></ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>  private fun drawHeader(c: Canvas, header: View) {
      c.save()
      c.translate(0F, 0F)
      header.draw(c)
      c.restore()
  }
</pre></table></code></div></div><ul><li>Trường hợp 2 header tiếp xúc với nhau, ta sẽ vẽ header cũ lùi lên trên, lên trên bao nhiêu sẽ tùy vào header tiếp theo:</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>  private fun moveHeader(c: Canvas, currentHeader: View, nextHeader: View?) {
      c.save()
      c.translate(0F, (nextHeader!!.top - currentHeader.height).toFloat())
      currentHeader.draw(c)
      c.restore()
  }
</pre></table></code></div></div><p>Thêm một điểm cần lưu ý nữa, ta cần có một method để xác định xem: liệu 2 header có tiếp xúc với nhau hay chưa:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>  private fun getChildInContact(parent: RecyclerView, contactPoint: Int): View? {
      var childInContact: View? = null
      for (i in 0 until parent.childCount) {
          val child = parent.getChildAt(i)
          if (child.bottom &gt; contactPoint &amp;&amp; child.top &lt;= contactPoint) {
              // This child overlaps the contactPoint
              childInContact = child
              break
          }
      }
      return childInContact
  }
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">contactPoint</code> mà chúng ta cần truyền vào để kiểm tra kia, sẽ là tọa độ của điểm thấp nhất (<code class="language-plaintext highlighter-rouge">bottom</code>) của header. Ta sẽ duyệt tất cả child của <code class="language-plaintext highlighter-rouge">RecyclerView</code>, sau đó kiểm tra xem nếu <code class="language-plaintext highlighter-rouge">bottom</code> của child lớn hơn <code class="language-plaintext highlighter-rouge">contactPoint</code> và phần trên cùng (<code class="language-plaintext highlighter-rouge">top</code>) của child nhỏ hơn (đã đè lên) hoặc bằng (bắt đầu tiếp xúc) với <code class="language-plaintext highlighter-rouge">contactPoint</code>, khi đó ta sẽ trả về view mà tiếp xúc với <code class="language-plaintext highlighter-rouge">contactPoint</code> kia. Vậy câu hỏi được đặt ra khi nhìn thấy kiểu giá trị trả về của method này là: liệu có bao giờ, không có child view nào tiếp xúc với <code class="language-plaintext highlighter-rouge">contactPoint</code> không? Nghĩ đơn giản một chút, thì lúc nào mà chả có 1 item nào đấy đang contact với header cũ đúng không? Tuy nhiên, trước khi trả lời câu hỏi đấy, bạn cần trả lời một câu hỏi khác: khi bạn ngăn cách 2 item trong list một khoảng nào đó, bạn có thể sử dụng dù là margin hay override lại <code class="language-plaintext highlighter-rouge">getItemOffsets</code> của <code class="language-plaintext highlighter-rouge">ItemDecoration</code>, phần ngăn cách đấy có được tính là thuộc về item không? Nếu như đã đọc kỹ phần 1, câu trả lời là không (sử dụng margin, câu trả lời cũng tương tự). Vậy, đáp án của câu hỏi <em>trên trên một tí</em> là có - sẽ có lúc, không có item nào tiếp xúc với header đang được stick. Và khi không tiếp xúc, chúng ta sẽ vẽ header như bình thường mà không cần phải quan tâm đến vị trí của header làm gì cả.</p><p>Cuối cùng, khi đã tìm được cách giải quyết của các vấn đề, ta sẽ implement method <code class="language-plaintext highlighter-rouge">onDrawOver</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>  override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
      super.onDrawOver(c, parent, state)

      val topChild = parent.getChildAt(0) ?: return

      val topChildPosition = parent.getChildAdapterPosition(topChild)
      if (topChildPosition == RecyclerView.NO_POSITION) {
          return
      }

      getHeaderViewForItem(topChildPosition, parent)
      val contactPoint = headerView!!.bottom
      val childInContact = getChildInContact(parent, contactPoint)

      if (childInContact != null &amp;&amp; mListener.isHeader(parent.getChildAdapterPosition(childInContact))) {
          moveHeader(c, headerView!!, childInContact)
          return
      }

      drawHeader(c, headerView!!)
  }
</pre></table></code></div></div><p>Ở đây, method <code class="language-plaintext highlighter-rouge">getHeaderViewForItem</code> sẽ làm nhiệm vụ inflate view cho header + bindData vào header đó.</p><h1 id="túm-cái-váy-lại">Túm cái váy lại</h1><blockquote><p>Mọi con đường đều dẫn đến thành Rome</p></blockquote><p>Tuy nhiên, con đường nào mà ít phải chịu hiểm nguy nhất là do bạn chọn. Khi còn là một kẻ học việc, bạn hoàn toàn có thể sử dụng những con đường tắt nhưng cũng đầy nguy cơ rình rập để đạt được kết quả như ý muốn. Nhưng một khi đã đạt được điều mình mong muốn, hãy quay trở lại, tìm tòi và chọn lại cho mình con đường đúng đắn nhất (và có thể là công cụ đúng đắn nhất), dù đó không phải là con đường ngắn nhất. Và khi đó, bạn sẽ có những bước đi an toàn và chắc chắn nhất.</p><p>Với <code class="language-plaintext highlighter-rouge">ItemDecoration</code> cũng vậy, nó thực sự là <em>a right tool</em> để decor <code class="language-plaintext highlighter-rouge">RecyclerView</code> chứ không phải dùng những mẹo như các dev vẫn hay dùng. Ngoài ra, bạn có thể sử dụng nhiều <code class="language-plaintext highlighter-rouge">ItemDecoration</code> đối với một <code class="language-plaintext highlighter-rouge">RecyclerView</code>. Giới hạn bây giờ chỉ là ở khả năng sáng tạo của bạn mà thôi!</p><p>Các bạn có thể tham khảo <a href="https://github.com/srinnix1395/StickyHeaderRecylerView">source code</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >android</a> <a href="/tags/recyclerview/" class="post-tag no-text-decoration" >recyclerview</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Android] Implement StickyHeaderRecyclerView với ItemDecoration của RecyclerView - srinnix13&url=https://srinnix1395.github.io/posts/Android-Implement-StickyHeaderRecyclerView-v%E1%BB%9Bi-ItemDecoration-c%E1%BB%A7a-RecyclerView/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Android] Implement StickyHeaderRecyclerView với ItemDecoration của RecyclerView - srinnix13&u=https://srinnix1395.github.io/posts/Android-Implement-StickyHeaderRecyclerView-v%E1%BB%9Bi-ItemDecoration-c%E1%BB%A7a-RecyclerView/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Android] Implement StickyHeaderRecyclerView với ItemDecoration của RecyclerView - srinnix13&url=https://srinnix1395.github.io/posts/Android-Implement-StickyHeaderRecyclerView-v%E1%BB%9Bi-ItemDecoration-c%E1%BB%A7a-RecyclerView/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://srinnix1395.github.io/posts/Android-Implement-StickyHeaderRecyclerView-v%E1%BB%9Bi-ItemDecoration-c%E1%BB%A7a-RecyclerView/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-IV/">[Android] Dagger 2 - Phần IV: A new horizon</a><li><a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-I/">[Android] Dagger 2 - Phần I: Basic principles</a><li><a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-II/">[Android] Dagger 2 - Phần II: Into the Dagger 2</a><li><a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-1/">[Android] Dagger 2 - Phần III - 1: The time of our dependencies</a><li><a href="/posts/Android-Dagger-2-Ph%E1%BA%A7n-III-2/">[Android] Dagger 2 - Phần III - 2: The time of our dependencies</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/dagger/">dagger</a> <a class="post-tag" href="/tags/dependency-injection/">dependency injection</a> <a class="post-tag" href="/tags/bitmap/">bitmap</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/image/">image</a> <a class="post-tag" href="/tags/layout/">layout</a> <a class="post-tag" href="/tags/recyclerview/">recyclerview</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Android-Constraint-layout-Ph%E1%BA%A7n-1-Thi%E1%BA%BFt-k%E1%BA%BF/"><div class="card-body"> <span class="timeago small" > Sep 27, 2017 <i class="unloaded">2017-09-27T07:42:03+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] Constraint layout - Phần 1: Thiết kế</h3><div class="text-muted small"><p> Khi xây dựng một màn hình có dạng một list các item trong Android, ta sẽ phải thiết kế layout cho các item của list đó, list đó có thể như thế này chẳng hạn: Với item hiển thị contact như trong ...</p></div></div></a></div><div class="card"> <a href="/posts/Android-T%E1%BA%A1o-thumbnail-cho-l%E1%BA%A7n-%C4%91%E1%BA%A7u-ti%C3%AAn/"><div class="card-body"> <span class="timeago small" > Mar 17 <i class="unloaded">2021-03-17T07:42:03+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] Tạo thumbnail cho lần đầu tiên</h3><div class="text-muted small"><p> Upload ảnh là một chức năng thường thấy ở các ứng dụng trên smartphone hiện nay. Tuy nhiên, khi upload một tấm ảnh lên, các ứng dụng thường sẽ scale down tấm ảnh đó xuống đến một size nào đó để giả...</p></div></div></a></div><div class="card"> <a href="/posts/Android-Dagger2-Ph%E1%BA%A7n-I/"><div class="card-body"> <span class="timeago small" > Apr 20 <i class="unloaded">2021-04-20T07:42:01+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] Dagger 2 - Phần I: Basic principles</h3><div class="text-muted small"><p> Mình biết đến Dagger (chính xác là Dagger 2) khi còn đi thực tập ở một công ty. Vì chỉ là một android intern làm việc 4 tiếng một ngày nên công việc chính của mình chỉ là fix một vài cái issue bé b...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Android-Constraint-layout-Ph%E1%BA%A7n-1-Thi%E1%BA%BFt-k%E1%BA%BF/" class="btn btn-outline-primary" prompt="Older"><p>[Android] Constraint layout - Phần 1: Thiết kế</p></a> <a href="/posts/Android-T%E1%BA%A1o-thumbnail-cho-l%E1%BA%A7n-%C4%91%E1%BA%A7u-ti%C3%AAn/" class="btn btn-outline-primary" prompt="Newer"><p>[Android] Tạo thumbnail cho lần đầu tiên</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/srinnix13">tuha3</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/dagger/">dagger</a> <a class="post-tag" href="/tags/dependency-injection/">dependency injection</a> <a class="post-tag" href="/tags/bitmap/">bitmap</a> <a class="post-tag" href="/tags/design/">design</a> <a class="post-tag" href="/tags/image/">image</a> <a class="post-tag" href="/tags/layout/">layout</a> <a class="post-tag" href="/tags/recyclerview/">recyclerview</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://srinnix1395.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
